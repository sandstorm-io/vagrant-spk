#!/usr/bin/env python3
#   Copyright 2015-2018 Sandstorm Development Group, Inc. and contributors
#   Copyright 2024-2026 Contributors
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.

# Example usage:
# lima-spk setupvm lemp
# lima-spk vm up
# lima-spk init
# lima-spk dev
# lima-spk pack output.spk

from __future__ import print_function

__version__ = "v0.1.0"

import argparse
import json
import os
import hashlib
import re
import shlex
import shutil
import subprocess
import sys

PWD = os.getcwd()

CODE_DIR = os.path.dirname(os.path.realpath(__file__))

# Lima instance name prefix
LIMA_INSTANCE_PREFIX = "sandstorm"

# Port for Sandstorm dev server
SANDSTORM_PORT = 6090

def get_lima_instance_name(work_directory):
    """Generate a unique Lima instance name based on the work directory."""
    # Use a hash of the absolute path to ensure uniqueness
    dir_hash = hashlib.md5(os.path.abspath(work_directory).encode()).hexdigest()[:8]
    base_name = os.path.basename(os.path.abspath(work_directory))
    # Lima instance names must be valid hostnames
    safe_name = re.sub(r'[^a-zA-Z0-9-]', '-', base_name).lower()
    return f"{LIMA_INSTANCE_PREFIX}-{safe_name}-{dir_hash}"

def get_lima_yaml_contents():
    """Generate Lima YAML configuration."""
    return f'''# Lima configuration for Sandstorm development
# Generated by lima-spk

# Sandstorm requires x86_64 architecture
arch: x86_64
vmType: qemu

# Use Debian Bookworm for compatibility with Sandstorm
images:
  - location: "https://cloud.debian.org/images/cloud/bookworm/latest/debian-12-generic-amd64.qcow2"
    arch: x86_64

# Resource allocation
cpus: 4
memory: "3GiB"
disk: "20GiB"

# Disable containerd/nerdctl (not needed for Sandstorm)
containerd:
  system: false
  user: false

# Mounts:
# - The project directory is mounted at /opt/app via --set when running `lima-spk vm up`
# - ~/.sandstorm is mounted for sharing keys and caches
mounts:
  - location: "~/.sandstorm"
    mountPoint: "/host-dot-sandstorm"
    writable: true

# Forward the Sandstorm dev port
portForwards:
  - guestPort: {SANDSTORM_PORT}
    hostIP: "127.0.0.1"
    hostPort: {SANDSTORM_PORT}

# Provision the VM with Sandstorm
provision:
  - mode: system
    script: |
      #!/bin/bash
      set -euo pipefail
      if [ -f /opt/app/.sandstorm/global-setup.sh ]; then
        bash /opt/app/.sandstorm/global-setup.sh
      fi
  - mode: system
    script: |
      #!/bin/bash
      set -euo pipefail
      if [ -f /opt/app/.sandstorm/setup.sh ]; then
        bash /opt/app/.sandstorm/setup.sh
      fi

# Use 'vagrant' user for compatibility with vagrant-spk scripts
user:
  name: vagrant

# SSH configuration
ssh:
  localPort: 0
  forwardAgent: false

# Message shown after VM starts
message: |
  Your Sandstorm dev environment is running.
  Access it at http://local.sandstorm.io:{SANDSTORM_PORT}

  To SSH: lima-spk vm ssh
  To stop: lima-spk vm halt
  To delete: lima-spk vm destroy
'''

GITATTRIBUTES_CONTENTS = r"""

# lima-spk creates shell scripts, which must end in \n, even on a \r\n system.
*.sh text eol=lf

"""

GITIGNORE_CONTENTS = r"""

# This file stores a list of sub-paths of .sandstorm/ that should be ignored by git.

# Lima sometimes generates log files:
*.log

"""

GLOBAL_SETUP_SCRIPT = r"""#!/bin/bash
set -euo pipefail

# CAUTION: DO NOT MAKE CHANGES TO THIS FILE. The lima-spk upgradevm process will overwrite it.
# App-specific setup should be done in the setup.sh file.

CURL_OPTS="--silent --show-error"
echo localhost > /etc/hostname
hostname localhost

# Grub updates don't silent install well
apt-mark hold grub-pc || true
apt-get update
apt-get upgrade -y

# Install curl needed below, and gnupg for package signing
apt-get install -y curl gnupg netcat-openbsd


# The following line copies stderr through stderr to cat without accidentally leaving it in the
# output file.
curl $CURL_OPTS https://install.sandstorm.io/ 2>&1 > /host-dot-sandstorm/caches/install.sh | cat

SANDSTORM_CURRENT_VERSION=$(curl $CURL_OPTS -f "https://install.sandstorm.io/dev?from=0&type=install")
SANDSTORM_PACKAGE="sandstorm-$SANDSTORM_CURRENT_VERSION.tar.xz"
if [[ ! -f /host-dot-sandstorm/caches/$SANDSTORM_PACKAGE ]] ; then
    echo -n "Downloading Sandstorm version ${SANDSTORM_CURRENT_VERSION}..."
    curl $CURL_OPTS --output "/host-dot-sandstorm/caches/$SANDSTORM_PACKAGE.partial" "https://dl.sandstorm.io/$SANDSTORM_PACKAGE" 2>&1 | cat
    mv "/host-dot-sandstorm/caches/$SANDSTORM_PACKAGE.partial" "/host-dot-sandstorm/caches/$SANDSTORM_PACKAGE"
    echo "...done."
fi
if [ ! -e /opt/sandstorm/latest/sandstorm ] ; then
    echo -n "Installing Sandstorm version ${SANDSTORM_CURRENT_VERSION}..."
    bash /host-dot-sandstorm/caches/install.sh -d -e -p __SANDSTORM_PORT__ "/host-dot-sandstorm/caches/$SANDSTORM_PACKAGE" >/dev/null
    echo "...done."
fi
modprobe ip_tables || true
# Make the vagrant user part of the sandstorm group so that commands like
# `spk dev` work.
usermod -a -G 'sandstorm' 'vagrant'
# Bind to all addresses, so the port-forward works.
sudo sed --in-place='' \
        --expression='s/^BIND_IP=.*/BIND_IP=0.0.0.0/' \
        /opt/sandstorm/sandstorm.conf

# Force lima-spk to use the strict CSP, see sandstorm#3424 for details.
echo 'ALLOW_LEGACY_RELAXED_CSP=false' >> /opt/sandstorm/sandstorm.conf

sudo service sandstorm restart
# Enable apt-cacher-ng proxy to make things faster if one appears to be running on the gateway IP
GATEWAY_IP=$(ip route  | grep ^default  | cut -d ' ' -f 3) || true
if [ -n "$GATEWAY_IP" ] && nc -z "$GATEWAY_IP" 3142 2>/dev/null; then
    echo "Acquire::http::Proxy \"http://$GATEWAY_IP:3142\";" > /etc/apt/apt.conf.d/80httpproxy
fi
# Configure apt to retry fetching things that fail to download.
echo "APT::Acquire::Retries \"10\";" > /etc/apt/apt.conf.d/80sandstorm-retry
"""

EMPTY_BUILD_SCRIPT = r"""#!/bin/bash
set -euo pipefail
# This is a script that is run every time you call "lima-spk dev".
# It is intended to do platform-and-repository-specific build steps.  You
# might customize it to do any of the following, or more:
# - for Python, prepare a virtualenv and pip install -r requirements.txt
# - for PHP, call composer to retrieve additional packages
# - for JS/CSS/SASS/LESS, compile, minify, or otherwise do asset pipeline work.
# This particular script does nothing at present, but you should adapt it
# sensibly for your package.

exit 0
"""

TMP_LIMA_SPK_LOCATION = '/var/tmp/lima-spk'

def format_shell_grain_choices(supervisors):
    '''Return a formatted message asking which grain to attach to.'''
    assert supervisors
    msg = (
'''This will run a shell in the context of a grain. Here is a list of running
grains you can attach to. Press enter to choose the first one, or type the
number next to the grain ID to choose it.''' + '\n\n')
    for i, datum in enumerate(supervisors):
        human_printable_i = i + 1
        msg += f"{human_printable_i}. {datum['grain_id']}\n"
    msg += '\n'
    msg += 'Your choice: [1] '
    return msg

def check_dot_sandstorm(work_directory):
    """Check that .sandstorm folder and lima.yaml exist."""
    sandstorm_dir = os.path.join(work_directory, ".sandstorm")
    if not os.path.isdir(sandstorm_dir):
        sys.stderr.write(f"No .sandstorm folder found at {os.path.abspath(sandstorm_dir)}\n")
        sys.stderr.write("Try 'lima-spk setupvm <stack>' first.\n")
        sys.exit(1)
    lima_yaml_path = os.path.join(sandstorm_dir, "lima.yaml")
    if not os.path.exists(lima_yaml_path):
        # Check if this was set up with vagrant-spk
        if os.path.exists(os.path.join(sandstorm_dir, "Vagrantfile")):
            print("Found .sandstorm directory from vagrant-spk. Generating lima.yaml...")
            with open(lima_yaml_path, "w") as f:
                f.write(get_lima_yaml_contents())
            print(f"Created {lima_yaml_path}")
        else:
            sys.stderr.write(f"No lima.yaml found at {lima_yaml_path}\n")
            sys.stderr.write("Try 'lima-spk setupvm <stack>' first.\n")
            sys.exit(1)

def require_running_vm(work_directory):
    """Check that the VM is running and return the instance name."""
    instance_name = get_lima_instance_name(work_directory)
    status = get_lima_instance_status(instance_name)
    if status != 'Running':
        sys.stderr.write(f"Lima instance {instance_name} is not running.\n")
        sys.stderr.write("Start it with 'lima-spk vm up'\n")
        sys.exit(1)
    return instance_name

def get_lima_instance_status(instance_name):
    """Get the status of a Lima instance."""
    try:
        result = subprocess.run(
            ['limactl', 'list', '--json'],
            capture_output=True,
            text=True,
            check=True
        )
        # limactl outputs one JSON object per line (NDJSON format)
        for line in result.stdout.strip().split('\n'):
            if not line:
                continue
            try:
                instance = json.loads(line)
                if instance.get('name') == instance_name:
                    return instance.get('status', 'Unknown')
            except json.JSONDecodeError:
                continue
        return None
    except subprocess.CalledProcessError:
        return None

def call_lima_ssh_command_capturing_output(instance_name, command_string, assert_exit_success=True):
    """Execute a command in the Lima VM and capture output."""
    argv = ['limactl', 'shell', '--workdir', '/opt/app', instance_name, 'bash', '-c', command_string]
    p = subprocess.Popen(argv, stdout=subprocess.PIPE, stdin=subprocess.PIPE, stderr=subprocess.PIPE)
    out, err = p.communicate()
    if assert_exit_success and p.returncode != 0:
        raise ValueError(f"Command failed: {command_string}\nError: {err.decode('utf-8', errors='replace')}")
    return out

def call_lima_ssh_command_providing_stdin(instance_name, command_string, stdin, assert_exit_success=True):
    """Execute a command in the Lima VM with stdin."""
    argv = ['limactl', 'shell', '--workdir', '/opt/app', instance_name, 'bash', '-c', command_string]
    p = subprocess.Popen(argv, stdout=subprocess.PIPE, stdin=subprocess.PIPE, stderr=subprocess.PIPE)
    out, err = p.communicate(input=stdin)
    if assert_exit_success and p.returncode != 0:
        raise ValueError(f"Command failed: {command_string}\nError: {err.decode('utf-8', errors='replace')}")
    return out

def call_lima_command(instance_name, *command_args, interactive=False):
    """Execute a Lima command."""
    command = ["limactl"]
    command.extend(command_args)
    cmd_str = " ".join([f"'{arg}'" for arg in command])
    sys.stderr.write(f"Calling {cmd_str} for instance {instance_name}\n")
    try:
        if interactive:
            return subprocess.call(command)
        else:
            return subprocess.check_call(command)
    except subprocess.CalledProcessError as e:
        ANSI_RED = "\x1b[31m"
        ANSI_RESET = "\x1b[0m"
        msg = f"Command failed with a non-zero exit status ({e.returncode})."
        sys.exit(ANSI_RED + msg + ANSI_RESET)

def call_lima_shell_command(instance_name, command_string, interactive=False):
    """Execute a shell command in the Lima VM."""
    if interactive:
        return subprocess.call(['limactl', 'shell', '--workdir', '/opt/app', instance_name, 'bash', '-c', command_string])
    else:
        return subprocess.check_call(['limactl', 'shell', '--workdir', '/opt/app', instance_name, 'bash', '-c', command_string])

KEYRING_PATH = "/host-dot-sandstorm/sandstorm-keyring"

def call_spk_command(instance_name, spk_subcommand, extra_args="", use_keyring=True, interactive=False):
    """Execute an spk command in the Lima VM."""
    keyring_arg = f"--keyring={KEYRING_PATH}" if use_keyring else ""
    command = f"spk {spk_subcommand} {keyring_arg} {extra_args}".strip()
    # Clean up extra spaces
    command = " ".join(command.split())
    return call_lima_shell_command(instance_name, command, interactive=interactive)

def check_lima_installed():
    """Check that limactl is installed and available."""
    try:
        subprocess.run(
            ['limactl', '--version'],
            capture_output=True,
            check=True
        )
    except FileNotFoundError:
        sys.stderr.write("Error: limactl not found.\n")
        sys.stderr.write("Please install Lima first: brew install lima\n")
        sys.stderr.write("See https://lima-vm.io for more information.\n")
        sys.exit(1)
    except subprocess.CalledProcessError as e:
        sys.stderr.write(f"Error: limactl check failed with exit code {e.returncode}\n")
        sys.exit(1)

def ensure_host_sandstorm_folder_exists():
    """Ensure ~/.sandstorm exists for storing signing keys."""
    USER_SANDSTORM_DIR = os.path.join(os.path.expanduser("~"), ".sandstorm")
    if not os.path.exists(USER_SANDSTORM_DIR):
        print(f"Creating {USER_SANDSTORM_DIR} to hold developer keys.")
        os.makedirs(USER_SANDSTORM_DIR)
    USER_SANDSTORM_CACHE_DIR = os.path.join(USER_SANDSTORM_DIR, "caches")
    if not os.path.exists(USER_SANDSTORM_CACHE_DIR):
        print(f"Creating {USER_SANDSTORM_CACHE_DIR} to hold sandstorm installer caches.")
        os.makedirs(USER_SANDSTORM_CACHE_DIR)
    keyring_file = os.path.join(USER_SANDSTORM_DIR, "sandstorm-keyring")
    if not os.path.exists(keyring_file):
        with open(keyring_file, "wb") as f:
            pass

def confirm_overwrite(filepath, noninteractive):
    if noninteractive:
        return True
    if os.path.exists(filepath):
        resp = input("This command will overwrite some existing packaging configuration. Proceed? [y/N]: ").strip().lower()
        return resp == 'y'
    return True

class StackPlugin(object):
    def __init__(self, plugin_name):
        self._plugin_name = plugin_name
        plugin_dir = os.path.join(CODE_DIR, "stacks", self._plugin_name)
        if not os.path.exists(plugin_dir):
            raise Exception(f"No stack plugin for {plugin_name}")
        if (not os.path.exists(os.path.join(plugin_dir, "setup.sh")) or
            not os.path.exists(os.path.join(plugin_dir, "launcher.sh"))):
            raise Exception("Stack plugins require both 'setup.sh' and 'launcher.sh' scripts.")

    def plugin_file(self, filename):
        return os.path.join(CODE_DIR, "stacks", self._plugin_name, filename)

    def init_args(self):
        args_file = os.path.join(CODE_DIR, "stacks", self._plugin_name, "initargs")
        if os.path.exists(args_file):
            with open(args_file) as f:
                return f.read().strip()
        else:
            return ""

def setup_vm(args):
    if (len(args.command_specific_args) == 0):
        print("No stack specified.  Try specifying a stack with:")
        print("")
        print("lima-spk setupvm <stack>")
        print("")
        print("Supported stacks:")
        stacks_dir = os.path.join(CODE_DIR, "stacks")
        for stack in sorted(os.listdir(stacks_dir)):
            print(f"  {stack}")
        print("")
        sys.exit(1)

    stack_plugin_name = args.command_specific_args[0]
    stack_plugin = StackPlugin(stack_plugin_name)
    sandstorm_dir = os.path.join(args.work_directory, ".sandstorm")
    print(f"Initializing .sandstorm directory in {sandstorm_dir}")

    if not os.path.isdir(sandstorm_dir):
        os.makedirs(sandstorm_dir, mode=0o755)

    ensure_host_sandstorm_folder_exists()

    # Copy global setup script
    global_setup_script_path = os.path.join(sandstorm_dir, "global-setup.sh")
    noninteractive = getattr(args, 'noninteractive', False)
    if confirm_overwrite(global_setup_script_path, noninteractive):
        with open(global_setup_script_path, "wb") as f:
            f.write(GLOBAL_SETUP_SCRIPT.replace("__SANDSTORM_PORT__", str(SANDSTORM_PORT)).encode("UTF-8"))
        os.chmod(global_setup_script_path, 0o755)
    else:
        print("Aborted.")
        return

    # Copy stack-specific setup script
    setup_script_path = os.path.join(sandstorm_dir, "setup.sh")
    with open(setup_script_path, "wb") as f:
        with open(stack_plugin.plugin_file("setup.sh"), "rb") as g:
            f.write(g.read())
    os.chmod(setup_script_path, 0o755)

    # Copy build script
    build_script_path = os.path.join(sandstorm_dir, "build.sh")
    with open(build_script_path, "wb") as f:
        source_script_path = stack_plugin.plugin_file("build.sh")
        if os.path.exists(source_script_path):
            with open(source_script_path, "rb") as g:
                f.write(g.read())
        else:
            f.write(EMPTY_BUILD_SCRIPT.encode("UTF-8"))
    os.chmod(build_script_path, 0o755)

    # Copy launcher script
    launcher_script_path = os.path.join(sandstorm_dir, "launcher.sh")
    with open(launcher_script_path, "wb") as f:
        with open(stack_plugin.plugin_file("launcher.sh")) as g:
            f.write(g.read().encode("UTF-8"))
    os.chmod(launcher_script_path, 0o755)

    # Generate Lima YAML configuration
    lima_yaml_path = os.path.join(sandstorm_dir, "lima.yaml")
    with open(lima_yaml_path, "w") as f:
        f.write(get_lima_yaml_contents())

    # Copy service-config if present
    source_service_config_dir = stack_plugin.plugin_file("service-config")
    target_service_config_dir = os.path.join(sandstorm_dir, "service-config")

    # Write .gitignore
    gitignore_path = os.path.join(sandstorm_dir, ".gitignore")
    with open(gitignore_path, "wb") as f:
        f.write(GITIGNORE_CONTENTS.encode("UTF-8"))

    # Write .gitattributes
    gitattributes_path = os.path.join(sandstorm_dir, ".gitattributes")
    with open(gitattributes_path, "wb") as f:
        f.write(GITATTRIBUTES_CONTENTS.encode("UTF-8"))

    if os.path.exists(source_service_config_dir):
        if os.path.exists(target_service_config_dir):
            shutil.rmtree(target_service_config_dir)
        shutil.copytree(source_service_config_dir, target_service_config_dir)

    # Record which stack was used
    stack_path = os.path.join(sandstorm_dir, "stack")
    with open(stack_path, "w") as f:
        f.write(stack_plugin_name + "\n")

def upgrade_vm(args):
    sandstorm_dir = os.path.join(args.work_directory, ".sandstorm")
    print(f"Upgrading VM parameters in {sandstorm_dir}")

    global_setup_script_path = os.path.join(sandstorm_dir, "global-setup.sh")
    noninteractive = getattr(args, 'noninteractive', False)
    if confirm_overwrite(global_setup_script_path, noninteractive):
        with open(global_setup_script_path, "wb") as f:
            f.write(GLOBAL_SETUP_SCRIPT.replace("__SANDSTORM_PORT__", str(SANDSTORM_PORT)).encode("UTF-8"))
        os.chmod(global_setup_script_path, 0o755)
    else:
        print("Aborted.")
        return

    lima_yaml_path = os.path.join(sandstorm_dir, "lima.yaml")
    with open(lima_yaml_path, "w") as f:
        f.write(get_lima_yaml_contents())

def check_provisioned(instance_name):
    """Check if the VM has been provisioned with Sandstorm."""
    try:
        result = subprocess.run(
            ['limactl', 'shell', instance_name, 'test', '-e', '/opt/sandstorm/sandstorm.conf'],
            capture_output=True
        )
        return result.returncode == 0
    except:
        return False

def provision_vm(args):
    """Run the provisioning scripts inside the VM."""
    instance_name = require_running_vm(args.work_directory)

    print("Running provisioning scripts...")

    # Run global-setup.sh
    print("Running global-setup.sh (this may take a few minutes)...")
    try:
        subprocess.check_call([
            'limactl', 'shell', instance_name, 'sudo', 'bash', '-c',
            'if [ -f /opt/app/.sandstorm/global-setup.sh ]; then bash /opt/app/.sandstorm/global-setup.sh; fi'
        ])
    except subprocess.CalledProcessError as e:
        print(f"Warning: global-setup.sh failed with exit code {e.returncode}")

    # Run setup.sh
    print("Running setup.sh...")
    try:
        subprocess.check_call([
            'limactl', 'shell', instance_name, 'sudo', 'bash', '-c',
            'if [ -f /opt/app/.sandstorm/setup.sh ]; then bash /opt/app/.sandstorm/setup.sh; fi'
        ])
    except subprocess.CalledProcessError as e:
        print(f"Warning: setup.sh failed with exit code {e.returncode}")

    print("Provisioning complete.")

def bring_up_vm(args):
    sandstorm_dir = os.path.join(args.work_directory, ".sandstorm")
    instance_name = get_lima_instance_name(args.work_directory)
    lima_yaml_path = os.path.join(sandstorm_dir, "lima.yaml")
    app_dir = os.path.abspath(args.work_directory)

    ensure_host_sandstorm_folder_exists()

    status = get_lima_instance_status(instance_name)

    if status is None:
        # Instance doesn't exist, create it
        print(f"Creating Lima instance {instance_name}...")
        # Add project directory mount via --set (the lima.yaml only has ~/.sandstorm)
        mount_set = f'.mounts += [{{"location": "{app_dir}", "mountPoint": "/opt/app", "writable": true}}]'
        subprocess.check_call([
            'limactl', 'create',
            '--name', instance_name,
            '--set', mount_set,
            lima_yaml_path
        ])
        subprocess.check_call(['limactl', 'start', '--progress', instance_name])
    elif status == 'Stopped':
        # Instance exists but is stopped
        print(f"Starting Lima instance {instance_name}...")
        subprocess.check_call(['limactl', 'start', '--progress', instance_name])
    elif status == 'Running':
        print(f"Lima instance {instance_name} is already running.")
    else:
        print(f"Lima instance {instance_name} is in state: {status}")
        subprocess.check_call(['limactl', 'start', '--progress', instance_name])

    print(f"\nYour virtual server should be running at http://local.sandstorm.io:{SANDSTORM_PORT}")

def halt_vm(args):
    instance_name = get_lima_instance_name(args.work_directory)
    status = get_lima_instance_status(instance_name)

    if status == 'Running':
        print(f"Stopping Lima instance {instance_name}...")
        subprocess.check_call(['limactl', 'stop', instance_name])
    elif status is None:
        print(f"Lima instance {instance_name} does not exist.")
    else:
        print(f"Lima instance {instance_name} is already stopped.")

def destroy_vm(args):
    instance_name = get_lima_instance_name(args.work_directory)
    status = get_lima_instance_status(instance_name)

    if status is None:
        print(f"Lima instance {instance_name} does not exist.")
        return

    print(f"Destroying Lima instance {instance_name}...")
    subprocess.check_call(['limactl', 'delete', '--force', instance_name])

def reload_vm(args):
    """Restart the VM and re-run provisioning."""
    instance_name = get_lima_instance_name(args.work_directory)
    status = get_lima_instance_status(instance_name)

    if status is None:
        print(f"Lima instance {instance_name} does not exist.")
        print("Try 'lima-spk vm up' first.")
        sys.exit(1)

    if status == 'Running':
        print(f"Stopping Lima instance {instance_name}...")
        subprocess.check_call(['limactl', 'stop', instance_name])

    print(f"Starting Lima instance {instance_name}...")
    subprocess.check_call(['limactl', 'start', instance_name])

    print("Re-running provisioning scripts...")
    provision_vm(args)

    print(f"\nVM reloaded. Access it at http://local.sandstorm.io:{SANDSTORM_PORT}")

def ssh_vm(args):
    instance_name = require_running_vm(args.work_directory)
    subprocess.call(['limactl', 'shell', '--workdir', '/opt/app', instance_name])

def init(args):
    check_dot_sandstorm(args.work_directory)
    instance_name = require_running_vm(args.work_directory)
    sandstorm_dir = os.path.join(args.work_directory, ".sandstorm")

    pkgdef_path = os.path.join(sandstorm_dir, "sandstorm-pkgdef.capnp")
    noninteractive = getattr(args, 'noninteractive', False)
    if confirm_overwrite(pkgdef_path, noninteractive):
        stack_path = os.path.join(sandstorm_dir, "stack")
        with open(stack_path) as f:
            stack = f.read().strip()
        stack_plugin = StackPlugin(stack)
        init_args = stack_plugin.init_args()

        call_lima_shell_command(
            instance_name,
            f"spk init -p 8000 --keyring=/host-dot-sandstorm/sandstorm-keyring --output=/opt/app/.sandstorm/sandstorm-pkgdef.capnp {init_args} -- /bin/bash /opt/app/.sandstorm/launcher.sh"
        )
    else:
        print("Aborted.")
        return

def dev(args):
    check_dot_sandstorm(args.work_directory)
    instance_name = require_running_vm(args.work_directory)

    # Use sg to run with the sandstorm group (group membership changes require new session)
    call_lima_shell_command(
        instance_name,
        "sg sandstorm -c '/opt/app/.sandstorm/build.sh && cd /opt/app/.sandstorm && spk dev --pkg-def=/opt/app/.sandstorm/sandstorm-pkgdef.capnp:pkgdef'",
        interactive=True
    )

def shell(args):
    check_dot_sandstorm(args.work_directory)
    instance_name = require_running_vm(args.work_directory)
    sandstorm_dir = os.path.join(args.work_directory, ".sandstorm")

    try:
        filename = os.path.join(CODE_DIR, 'helpers', 'enter_grain')
        with open(filename, 'rb') as fd:
            enter_grain_binary = fd.read()
        with open(os.path.join(CODE_DIR, 'helpers', 'enter_grain.sha1'), 'rb') as fd:
            desired_checksum = fd.read().decode('utf-8').split(' ')[0].strip()
        found_checksum = hashlib.sha1(enter_grain_binary).hexdigest()
        if (desired_checksum and (desired_checksum != found_checksum)):
            raise RuntimeError("ERROR: This lima-spk bundle seems to be corrupt: bad checksum on enter_grain binary.")
    except Exception as e:
        sys.stderr.write("ERROR: Failed to load enter_grain binary.\n")
        raise

    sys.stderr.write("Looking for apps in dev mode...\n")

    data_from_guest = call_lima_ssh_command_capturing_output(
        instance_name,
        r'''pidof spk || echo no-spk;''' +
        r'''SANDSTORM_UID=$(id sandstorm | sed -r s,[^0-9],_,g | sed -r s,_+,_,g | cut -d _ -f 2 ) ; ''' +
        r'''for pid in $(pidof supervisor); do echo $pid $(cat /proc/$pid/status | grep -q 'Uid:.*'${SANDSTORM_UID} && echo ownership-correct || echo ownership-wrong) $(xargs -0 -n1 echo < /proc/$pid/cmdline  | grep -v -- - | head -n2 | tail -n1) $(grep -E -l ^PPid:[[:blank:]]*${pid}$ /proc/*/status | head -n1  | sed -r s,/proc/,,g | sed -r s,/status,,) ; done'''
    )

    splitted = data_from_guest.decode('utf-8').splitlines()
    spk_pid = splitted[0]
    if spk_pid == 'no-spk':
        sys.stderr.write("No Sandstorm supervisor processes found.\n" +
                         "Try `lima-spk dev` first.\n")
        sys.exit(1)
    supervisor_pid_info = splitted[1:]
    sys.stderr.write("Looking for grains...\n")
    if supervisor_pid_info:
        sys.stderr.write('\n')
    else:
        sys.stderr.write("No Sandstorm supervisor processes found.\n" +
                         "Make sure to open a grain of this app in your web browser.\n")
        sys.exit(1)
    supervisors = []
    for line in supervisor_pid_info:
        try:
            supervisor_pid, ownership_check, grain_id, child_pid = line.split()
        except:
            sys.stderr.write(f'Error parsing line: {line}. Crashing.\n')
            raise
        if ownership_check == 'ownership-correct':
            supervisors.append({
                'supervisor_pid': supervisor_pid,
                'grain_id': grain_id,
                'child_pid': int(child_pid),
            })

    if not supervisors:
        sys.stderr.write("No grains with correct ownership found.\n"
                         "Make sure to open a grain of this app in your web browser.\n")
        sys.exit(1)

    grain_choice_human_readable = input(format_shell_grain_choices(supervisors)).strip()
    if not grain_choice_human_readable:
        grain_choice_human_readable = "1"
    try:
        grain_choice_as_int = int(grain_choice_human_readable)
        chosen_supervisor = supervisors[grain_choice_as_int - 1]
    except (ValueError, IndexError):
        sys.stderr.write("Please enter a valid number (e.g. 1).\n")
        sys.exit(1)

    sys.stderr.write(f"OK. Chosen grain ID {chosen_supervisor['grain_id']}, whose child PID is {chosen_supervisor['child_pid']}. Attaching...\n")
    pid = chosen_supervisor['child_pid']
    tmp_lima_spk_dir = f'/proc/{pid}/root{TMP_LIMA_SPK_LOCATION}'
    enter_grain_binary_path = tmp_lima_spk_dir + '/enter-grain'

    # Inject enter_grain binary
    sys.stderr.write(f"Adding enter_grain program to the grain in {TMP_LIMA_SPK_LOCATION}/enter-grain...\n")
    commands = ' && '.join([
        f'sudo mkdir -p {tmp_lima_spk_dir}',
        f'if which sha1sum >/dev/null && sudo sha1sum {enter_grain_binary_path} 2>/dev/null | grep -q ^{desired_checksum} ; then sudo chmod 755 {enter_grain_binary_path} && exit 0 ; fi',
        f'sudo dd of={enter_grain_binary_path} 2>/dev/null',
        f'sudo chmod 755 {enter_grain_binary_path}',
    ])
    call_lima_ssh_command_providing_stdin(instance_name, commands, stdin=enter_grain_binary)

    subprocess.call(['limactl', 'shell', '--workdir', '/opt/app', instance_name, 'bash', '-c',
                     f'cd /opt/app/.sandstorm && sudo {enter_grain_binary_path} {pid}'])

    sys.stderr.write(
        "NOTE: You should discard all sandstorm-files.list changes from this session to avoid bloat!\n")

def pack(args):
    if len(args.command_specific_args) == 0:
        print("Please specify an output file - e.g.")
        print("  lima-spk pack myapp.spk")
        sys.exit(1)

    check_dot_sandstorm(args.work_directory)
    instance_name = require_running_vm(args.work_directory)
    output_spk = args.command_specific_args[0]

    call_lima_shell_command(
        instance_name,
        "cd /opt/app/.sandstorm/ && " +
        "spk pack --keyring=/host-dot-sandstorm/sandstorm-keyring --pkg-def=/opt/app/.sandstorm/sandstorm-pkgdef.capnp:pkgdef /tmp/sandstorm-package.spk && " +
        "spk verify --details /tmp/sandstorm-package.spk && " +
        "mv /tmp/sandstorm-package.spk /opt/app/sandstorm-package.spk"
    )

    shutil.move(os.path.join(args.work_directory, "sandstorm-package.spk"), output_spk)
    print(f"package produced at {output_spk}")

def verify(args):
    if len(args.command_specific_args) == 0:
        print("Please specify an .spk file to verify - e.g.")
        print("  lima-spk verify example.spk")
        sys.exit(1)

    check_dot_sandstorm(args.work_directory)
    instance_name = require_running_vm(args.work_directory)
    spk = args.command_specific_args[0]
    sandstorm_dir = os.path.join(args.work_directory, ".sandstorm")
    spk_basename = os.path.basename(spk)
    temp_spk = os.path.join(sandstorm_dir, spk_basename)

    try:
        shutil.copyfile(spk, temp_spk)
        call_spk_command(instance_name, "verify", f"--details /opt/app/.sandstorm/{shlex.quote(spk_basename)}", use_keyring=False)
    finally:
        os.remove(temp_spk)

def publish(args):
    if len(args.command_specific_args) == 0:
        print("Please specify an .spk file to publish - e.g.")
        print("  lima-spk publish example.spk")
        sys.exit(1)

    check_dot_sandstorm(args.work_directory)
    instance_name = require_running_vm(args.work_directory)
    spk = args.command_specific_args[0]
    sandstorm_dir = os.path.join(args.work_directory, ".sandstorm")
    spk_basename = os.path.basename(spk)
    temp_spk = os.path.join(sandstorm_dir, spk_basename)

    try:
        shutil.copyfile(spk, temp_spk)
        call_spk_command(instance_name, "publish", f"/opt/app/.sandstorm/{shlex.quote(spk_basename)}")
    finally:
        os.remove(temp_spk)

def keygen(args):
    check_dot_sandstorm(args.work_directory)
    instance_name = require_running_vm(args.work_directory)
    extra_args = " ".join(shlex.quote(arg) for arg in args.command_specific_args)
    call_spk_command(instance_name, "keygen", extra_args)

def listkeys(args):
    check_dot_sandstorm(args.work_directory)
    instance_name = require_running_vm(args.work_directory)
    extra_args = " ".join(shlex.quote(arg) for arg in args.command_specific_args)
    call_spk_command(instance_name, "listkeys", extra_args)

def getkey(args):
    if len(args.command_specific_args) == 0:
        print("Please specify a key ID - e.g.")
        print("  lima-spk getkey <key-id>")
        sys.exit(1)

    check_dot_sandstorm(args.work_directory)
    instance_name = require_running_vm(args.work_directory)
    key_id = shlex.quote(args.command_specific_args[0])
    call_spk_command(instance_name, "getkey", key_id)

def vm_subcommand(args):
    if len(args.command_specific_args) == 0:
        sys.stderr.write("Try specifying a command like:\n\n")
        sys.stderr.write("lima-spk vm up        - Start the VM\n")
        sys.stderr.write("lima-spk vm halt      - Stop the VM\n")
        sys.stderr.write("lima-spk vm ssh       - SSH into the VM\n")
        sys.stderr.write("lima-spk vm destroy   - Delete the VM\n")
        sys.stderr.write("lima-spk vm status    - Show VM status\n")
        sys.stderr.write("lima-spk vm provision - Re-run provisioning scripts\n")
        sys.stderr.write("lima-spk vm reload    - Restart VM and re-provision\n")
        sys.stderr.write("\n")
        sys.exit(1)

    check_dot_sandstorm(args.work_directory)
    ensure_host_sandstorm_folder_exists()
    instance_name = get_lima_instance_name(args.work_directory)

    subcommand = args.command_specific_args[0]

    if subcommand == 'up':
        bring_up_vm(args)
    elif subcommand == 'halt' or subcommand == 'stop':
        halt_vm(args)
    elif subcommand == 'destroy' or subcommand == 'delete':
        destroy_vm(args)
    elif subcommand == 'ssh' or subcommand == 'shell':
        ssh_vm(args)
    elif subcommand == 'status':
        status = get_lima_instance_status(instance_name)
        if status:
            print(f"Lima instance {instance_name}: {status}")
        else:
            print(f"Lima instance {instance_name} does not exist")
    elif subcommand == 'provision':
        provision_vm(args)
    elif subcommand == 'reload':
        reload_vm(args)
    elif subcommand == 'suspend' or subcommand == 'resume':
        print(f"Lima does not support '{subcommand}' yet.")
        print("You can use 'lima-spk vm halt' to stop the VM and 'lima-spk vm up' to start it again.")
        sys.exit(1)
    else:
        # Pass through to limactl
        remaining_args = args.command_specific_args[1:]
        call_lima_command(instance_name, subcommand, instance_name, *remaining_args)

class Command(object):
    def __init__(self, name, func, helptext, hidden=False):
        self.name = name
        self.func = func
        self.helptext = helptext
        self.hidden = hidden

def main():
    check_lima_installed()

    operations = [
        Command('setupvm', setup_vm,
            "Set up a fresh app environment in \n"
            "  --work-directory (using the provided `stack` \n"
            "  command arg).  Also inits developer keys in \n"
            "  ~/.sandstorm on this host."),
        Command('upgradevm', upgrade_vm,
            "Upgrade the Lima VM and setup scripts to \n"
            "  latest version included in lima-spk."),
        Command('vm', vm_subcommand,
            "Manage the Lima VM (up, halt, ssh, destroy, status, provision, reload)."),
        Command('vm up', None, "Start the Lima VM (and create it if needed)"),
        Command('vm halt', None, "Stop the Lima VM."),
        Command('vm destroy', None, "Delete the Lima VM (but leave --work-directory untouched)."),
        Command('vm ssh', None, "SSH into the Lima VM."),
        Command('vm status', None, "Show the status of the Lima VM."),
        Command('vm provision', None, "Re-run the provisioning scripts."),
        Command('vm reload', None, "Restart the VM and re-run provisioning."),
        Command('init', init,
            "Initialize fresh Sandstorm package definition \n"
            "  resources in --work-directory."),
        Command('dev', dev,
            "Make the current app available to Sandstorm \n"
            "  in dev mode (after bringing the Lima VM `up`)"),
        Command('enter-grain', shell, "Get a shell within a grain"),
        Command('pack', pack,
            "Pack the current app into a \n"
            "  Sandstorm package."),
        Command('verify', verify,
            "Show details of the specified Sandstorm package."),
        Command('publish', publish,
            "Send the current packed app spk to \n"
            "  the Sandstorm App Market."),
        Command('keygen', keygen,
            "Generate a new key, add it to your keyring,\n"
            "  and print the identifier."),
        Command('listkeys', listkeys,
            "List the keys in your keyring."),
        Command('getkey', getkey,
            "Given a key identifier, retrieve and print the\n"
            "  corresponding private key from your keyring."),
    ]

    op_to_func = dict((c.name, c.func) for c in operations if c.func)
    ops_helptext = '\n'.join(c.name + ': ' + c.helptext for c in operations if not c.hidden)
    parser = argparse.ArgumentParser(prog=sys.argv[0], formatter_class=argparse.RawTextHelpFormatter)
    parser.add_argument("command", choices=[c.name for c in operations if c.func], help=ops_helptext)
    parser.add_argument("command_specific_args", nargs="*")
    parser.add_argument("-V", "--version", action="version", version="lima-spk "+__version__)
    parser.add_argument(
        "--work-directory",
        action='store',
        default=PWD,
        help="Use this working directory (e.g. for .sandstorm/ \n"
             "and other configuration).  [Default: current \n"
             "working directory]")
    parser.add_argument('--noninteractive', action='store_true', help='Suppress overwrite prompts (use in scripts)')
    args = parser.parse_args(sys.argv[1:])
    operation = op_to_func[args.command]
    operation(args)

if __name__ == "__main__":
    main()
