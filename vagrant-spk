#!/usr/bin/env python
#   Copyright 2015 Drew Fisher (zarvox@zarvox.org)
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.

# Example usage:
# vagrant-spk setupvm lemp
# vagrant-spk up
# vagrant-spk init
# vagrant-spk dev
# vagrant-spk pack output.spk

import argparse
import os
import shutil
import subprocess
import sys

PWD = os.getcwd()
CODE_DIR = os.path.dirname(os.path.realpath(sys.argv[0]))
VAGRANTFILE_CONTENTS = r"""# -*- mode: ruby -*-
# vi: set ft=ruby :

# Vagrantfile API/syntax version. Don't touch unless you know what you're doing!
VAGRANTFILE_API_VERSION = "2"

Vagrant.configure(VAGRANTFILE_API_VERSION) do |config|
  # We base ourselves off the trusty (Ubuntu 14.04) base box.
  config.vm.box = "trusty64"

  # The url from which to fetch that base box.
  config.vm.box_url = "https://cloud-images.ubuntu.com/vagrant/trusty/current/trusty-server-cloudimg-amd64-vagrant-disk1.box"

  # We forward port 6080, the Sandstorm web port, so that developers can
  # visit their sandstorm app from their browser as local.sandstorm.io:6080
  # (aka 127.0.0.1:6080).
  config.vm.network :forwarded_port, guest: 6080, host: 6080

  # Use a shell script to "provision" the box. This installs Sandstorm using
  # the bundled installer.
  config.vm.provision "shell", inline: "sudo bash /opt/app/.sandstorm/global-setup.sh"
  # Then, do stack-specific and app-specific setup.
  config.vm.provision "shell", inline: "sudo bash /opt/app/.sandstorm/setup.sh"

  # Share a few host folders into the VM, since it'll need them
  config.vm.synced_folder "..", "/vagrant"
  config.vm.synced_folder "..", "/opt/app"
  config.vm.synced_folder ENV["HOME"] + "/.sandstorm", "/host-dot-sandstorm"

  # Calculate the number of CPUs and the amount of RAM the system has,
  # in a platform-dependent way; further logic below.
  cpus = nil
  total_kB_ram = nil

  host = RbConfig::CONFIG['host_os']
  if host =~ /darwin/
    cpus = `sysctl -n hw.ncpu`.to_i
    total_kB_ram =  `sysctl -n hw.memsize`.to_i / 1024
  elsif host =~ /linux/
    cpus = `nproc`.to_i
    total_kB_ram = `grep MemTotal /proc/meminfo | awk '{print $2}'`.to_i
  end
  # Use the same number of CPUs within Vagrant as the system, with 1
  # as a default.
  #
  # Use at least 512MB of RAM, and if the system has more than 2GB of
  # RAM, use 1/4 of the system RAM. This seems a reasonable compromise
  # between having the Vagrant guest operating system not run out of
  # RAM entirely (which it basically would if we went much lower than
  # 512MB) and also allowing it to use up a healthily large amount of
  # RAM so it can run faster on systems that can afford it.
  if cpus.nil?
    cpus = 1
  end
  if total_kB_ram.nil? or total_kB_ram < 2048000
    assign_ram_mb = 512
  else
    assign_ram_mb = (total_kB_ram / 1024 / 4)
  end
  # Actually apply these CPU/memory values to the providers.
  config.vm.provider :virtualbox do |vb|
    vb.cpus = cpus
    vb.memory = assign_ram_mb
  end
  config.vm.provider :libvirt do |libvirt|
    libvirt.cpus = cpus
    libvirt.memory = assign_ram_mb
  end
end
"""

GLOBAL_SETUP_SCRIPT = r"""#!/bin/bash
set -eu
echo localhost > /etc/hostname
hostname localhost
curl https://install.sandstorm.io/ > /host-dot-sandstorm/caches/install.sh
SANDSTORM_CURRENT_VERSION=$(curl -fs "https://install.sandstorm.io/dev?from=0&type=install")
SANDSTORM_PACKAGE="sandstorm-$SANDSTORM_CURRENT_VERSION.tar.xz"
if [[ ! -f /host-dot-sandstorm/caches/$SANDSTORM_PACKAGE ]] ; then
    curl --output "/host-dot-sandstorm/caches/$SANDSTORM_PACKAGE" "https://dl.sandstorm.io/$SANDSTORM_PACKAGE"
fi
bash /host-dot-sandstorm/caches/install.sh -d -e "/host-dot-sandstorm/caches/$SANDSTORM_PACKAGE"
modprobe ip_tables
# Make the vagrant user part of the sandstorm group so that commands like
# `spk dev` work.
usermod -a -G 'sandstorm' 'vagrant'
# Bind to all addresses, so the vagrant port-forward works.
sudo sed --in-place='' \
        --expression='s/^BIND_IP=.*/BIND_IP=0.0.0.0/' \
        /opt/sandstorm/sandstorm.conf
# TODO: update sandstorm installer script to ask about dev accounts, and
# specify a value for this option in the default config?
if ! grep --quiet --no-messages ALLOW_DEV_ACCOUNTS=true /opt/sandstorm/sandstorm.conf ; then
    echo "ALLOW_DEV_ACCOUNTS=true" | sudo tee -a /opt/sandstorm/sandstorm.conf
    sudo service sandstorm restart
fi
# stop some other services that are running by default in vagrant VMs
sudo service puppet stop
sudo service chef-client stop
# Enable apt-cacher-ng proxy to make things faster if one appears to be running on the gateway IP
GATEWAY_IP=$(ip route  | grep ^default  | cut -d ' ' -f 3)
if nc -z "$GATEWAY_IP" 3142 ; then
    echo "Acquire::http::Proxy \"http://$GATEWAY_IP:3142\";" > /etc/apt/apt.conf.d/80httpproxy
fi
"""

EMPTY_BUILD_SCRIPT = r"""#!/bin/bash
# This is a script that is run every time you call "vagrant-spk dev".
# It is intended to do platform-and-repository-specific build steps.  You
# might customize it to do any of the following, or more:
# - for Python, prepare a virtualenv and pip install -r requirements.txt
# - for PHP, call composer to retrieve additional packages
# - for JS/CSS/SASS/LESS, compile, minify, or otherwise do asset pipeline work.
# This particular script does nothing at present, but you should adapt it
# sensibly for your package.

exit 0
"""

LEMP_SETUP_SCRIPT = r"""#!/bin/bash
export DEBIAN_FRONTEND=noninteractive
apt-get update
apt-get install -y nginx php5-fpm php5-mysql php5-cli php5-curl git php5-dev mysql-server
unlink /etc/nginx/sites-enabled/default
cat > /etc/nginx/sites-available/sandstorm-php <<EOF
server {
    listen 8000 default_server;
    listen [::]:8000 default_server ipv6only=on;

    server_name localhost;
    root /opt/app;
    location / {
        index index.php;
        try_files \$uri \$uri/ =404;
    }
    location ~ \\.php\$ {
        fastcgi_split_path_info ^(.+\\.php)(/.+)\$;
        fastcgi_pass unix:/var/run/php5-fpm.sock;
        fastcgi_index index.php;
        include fastcgi_params;
    }
}
EOF
ln -s /etc/nginx/sites-available/sandstorm-php /etc/nginx/sites-enabled/sandstorm-php
service nginx stop
service php5-fpm stop
service mysql stop
# patch /etc/php5/fpm/php-fpm.conf to not change uid/gid to www-data
sed --in-place='' \
        --expression='s/^listen.owner = www-data/#listen.owner = www-data/' \
        --expression='s/^listen.group = www-data/#listen.group = www-data/' \
        --expression='s/^user = www-data/#user = www-data/' \
        --expression='s/^group = www-data/#group = www-data/' \
        /etc/php5/fpm/pool.d/www.conf
# patch mysql conf to not change uid
sed --in-place='' \
        --expression='s/^user\t\t= mysql/#user\t\t= mysql/' \
        /etc/mysql/my.cnf
# patch nginx conf to not bother trying to setuid, since we're not root
sed --in-place='' \
        --expression 's/^user www-data/#user www-data/' \
        --expression 's#^pid /run/nginx.pid#pid /var/run/nginx.pid#' \
        /etc/nginx/nginx.conf
# Add a conf snippet providing what sandstorm-http-bridge says the protocol is as var fe_https
cat > /etc/nginx/conf.d/50sandstorm.conf << EOF
    # Trust the sandstorm-http-bridge's X-Forwarded-Proto.
    map \$http_x_forwarded_proto \$fe_https {
        default "";
        https on;
    }
EOF
# Adjust fastcgi_params to use the patched fe_https
sed --in-place='' \
        --expression 's/^fastcgi_param\tHTTPS.*$/fastcgi_param\tHTTPS\t\t\$fe_https if_not_empty;/' \
        /etc/nginx/fastcgi_params
"""

LEMP_BUILD_SCRIPT = r"""#!/bin/bash
# Checks if there's a composer.json, and if so, installs/runs composer.

set -eu

cd /opt/app

if [ -f /opt/app/frontend/composer.json ] ; then
    if [ ! -f composer.phar ] ; then
        curl -sS https://getcomposer.org/installer | php
    fi
    cd /opt/app/frontend
    php ../composer.phar install
    php ../composer.phar self-update
fi
"""

LEMP_LAUNCHER_SCRIPT = r"""#!/bin/bash

# Create a bunch of folders under the clean /var that php, nginx, and mysql expect to exist
mkdir -p /var/lib/mysql
mkdir -p /var/lib/nginx
mkdir -p /var/log
mkdir -p /var/log/mysql
mkdir -p /var/log/nginx
# Wipe /var/run, since pidfiles and socket files from previous launches should go away
# TODO someday: I'd prefer a tmpfs for these.
rm -rf /var/run
mkdir -p /var/run
mkdir -p /var/run/mysqld

# Ensure mysql tables created
HOME=/etc/mysql /usr/bin/mysql_install_db --force

# Spawn mysqld, php
HOME=/etc/mysql /usr/sbin/mysqld &
/usr/sbin/php5-fpm --nodaemonize --fpm-config /etc/php5/fpm/php-fpm.conf &
# Wait until mysql and php have bound their sockets, indicating readiness
while [ ! -e /var/run/mysqld/mysqld.sock ] ; do
    echo "waiting for mysql to be available at /var/run/mysqld/mysqld.sock"
    sleep .2
done
while [ ! -e /var/run/php5-fpm.sock ] ; do
    echo "waiting for php5-fpm to be available at /var/run/php5-fpm.sock"
    sleep .2
done

# Start nginx.
/usr/sbin/nginx -g "daemon off;"
"""

NGINX_UWSGI_SETUP_SCRIPT = r"""
export DEBIAN_FRONTEND=noninteractive
apt-get update
apt-get install -y nginx mysql-server libmysqlclient-dev uwsgi uwsgi-plugin-python build-essential python-dev python-virtualenv
# Set up nginx conf
unlink /etc/nginx/sites-enabled/default
cat > /etc/nginx/sites-available/sandstorm-python <<EOF
server {
    listen 8000 default_server;
    listen [::]:8000 default_server ipv6only=on;

    server_name localhost;
    root /opt/app;
    location /static/ {
        alias /opt/app/static/;
    }
    location / {
        uwsgi_pass unix:///var/run/uwsgi.sock;
        include uwsgi_params;
    }
}
EOF
ln -s /etc/nginx/sites-available/sandstorm-python /etc/nginx/sites-enabled/sandstorm-python
# patch mysql conf to not change uid
sed --in-place='' \
        --expression='s/^user\t\t= mysql/#user\t\t= mysql/' \
        /etc/mysql/my.cnf
# patch nginx conf to not bother trying to setuid, since we're not root
sed --in-place='' \
        --expression 's/^user www-data/#user www-data/' \
        --expression 's#^pid /run/nginx.pid#pid /var/run/nginx.pid#' \
        /etc/nginx/nginx.conf
service nginx stop
service mysql stop
"""

NGINX_UWSGI_BUILD_SCRIPT = r"""#!/bin/bash
VENV=/opt/app/env
if [ ! -d $VENV ] ; then
    virtualenv $VENV
else
    echo "$VENV exists, moving on"
fi

if [ -f /opt/app/requirements.txt ] ; then
    $VENV/bin/pip install -r /opt/app/requirements.txt
fi
"""

NGINX_UWSGI_LAUNCHER_SCRIPT = r"""#!/bin/bash
# something something folders
mkdir -p /var/lib/mysql
mkdir -p /var/lib/nginx
mkdir -p /var/log
mkdir -p /var/log/mysql
mkdir -p /var/log/nginx
# Wipe /var/run, since pidfiles and socket files from previous launches should go away
# TODO someday: I'd prefer a tmpfs for these.
rm -rf /var/run
mkdir -p /var/run
mkdir -p /var/run/mysqld

UWSGI_SOCKET_FILE=/var/run/uwsgi.sock

# Ensure mysql tables created
HOME=/etc/mysql /usr/bin/mysql_install_db --force

# Spawn mysqld
HOME=/etc/mysql /usr/sbin/mysqld &

MYSQL_SOCKET_FILE=/var/run/mysqld/mysqld.sock
# Wait for mysql to bind its socket
while [ ! -e $MYSQL_SOCKET_FILE ] ; do
    echo "waiting for mysql to be available at $MYSQL_SOCKET_FILE"
    sleep .2
done

# Spawn uwsgi
HOME=/var uwsgi \
        --socket $UWSGI_SOCKET_FILE \
        --plugin python \
        --virtualenv /opt/app/env \
        --wsgi-file /opt/app/main.py &

# Wait for uwsgi to bind its socket
while [ ! -e $UWSGI_SOCKET_FILE ] ; do
    echo "waiting for uwsgi to be available at $UWSGI_SOCKET_FILE"
    sleep .2
done

# Start nginx.
/usr/sbin/nginx -g "daemon off;"
"""

STATIC_NGINX_SETUP_SCRIPT = r"""
export DEBIAN_FRONTEND=noninteractive
apt-get update
apt-get install -y nginx
# Set up nginx conf
unlink /etc/nginx/sites-enabled/default
cat > /etc/nginx/sites-available/sandstorm-static <<EOF
server {
    listen 8000 default_server;
    listen [::]:8000 default_server ipv6only=on;

    server_name localhost;
    root /opt/app;
}
EOF
ln -s /etc/nginx/sites-available/sandstorm-static /etc/nginx/sites-enabled/sandstorm-static
# patch nginx conf to not bother trying to setuid, since we're not root
sed --in-place='' \
        --expression 's/^user www-data/#user www-data/' \
        --expression 's#^pid /run/nginx.pid#pid /var/run/nginx.pid#' \
        /etc/nginx/nginx.conf
service nginx stop
"""

STATIC_NGINX_LAUNCHER_SCRIPT = r"""#!/bin/bash
mkdir -p /var/lib/nginx
mkdir -p /var/log/nginx
# Wipe /var/run, since pidfiles and socket files from previous launches should go away
# TODO someday: I'd prefer a tmpfs for these.
rm -rf /var/run
mkdir -p /var/run

# Start nginx.
/usr/sbin/nginx -g "daemon off;"
"""

# TODO: add more stack-specific plugins
STACK_PLUGINS = {
    "lemp": {
        "setup": LEMP_SETUP_SCRIPT,
        "launcher": LEMP_LAUNCHER_SCRIPT,
        "build": LEMP_BUILD_SCRIPT,
    },
    "uwsgi": {
        "setup": NGINX_UWSGI_SETUP_SCRIPT,
        "launcher": NGINX_UWSGI_LAUNCHER_SCRIPT,
        "build": NGINX_UWSGI_BUILD_SCRIPT,
    },
    "static": {
        "setup": STATIC_NGINX_SETUP_SCRIPT,
        "launcher": STATIC_NGINX_LAUNCHER_SCRIPT,
    },
}

def check_dot_sandstorm():
    expected_path = os.path.join(PWD, ".sandstorm")
    if not os.path.isdir(expected_path):
        raise Exception("expected to find a .sandstorm folder at {}".format(os.path.abspath(expected_path)))
    expected_vagrantfile_path = os.path.join(expected_path, "Vagrantfile")
    if not os.path.exists(expected_vagrantfile_path):
        raise Exception("expected a Vagrantfile at {} - try 'vagrant-spk setupvm lemp' to generate one".format(expected_vagrantfile_path))

def call_vagrant_command(sandstorm_dir, *command_args):
    command = ["vagrant"]
    command.extend(command_args)
    print "Calling {} in {}".format(" ".join(["'{}'".format(arg) for arg in command]), sandstorm_dir)
    return subprocess.check_call(command, cwd=sandstorm_dir)

def ensure_host_sandstorm_folder_exists():
    # We wrap the keyring in an additional folder, because Vagrant shared
    # folders can't share single files, only folders, and I don't want to give
    # the VM read/write access to the user's entire homedir, just the sandstorm
    # keyring.
    USER_SANDSTORM_DIR = os.path.join(os.path.expanduser("~"), ".sandstorm")
    if not os.path.exists(USER_SANDSTORM_DIR):
        print "Creating {} to hold developer keys.".format(USER_SANDSTORM_DIR)
        os.makedirs(USER_SANDSTORM_DIR)
    USER_SANDSTORM_CACHE_DIR = os.path.join(USER_SANDSTORM_DIR, "caches")
    if not os.path.exists(USER_SANDSTORM_CACHE_DIR):
        print "Creating {} to hold sandstorm installer caches.".format(USER_SANDSTORM_CACHE_DIR)
        os.makedirs(USER_SANDSTORM_CACHE_DIR)
    # Sandstorm is unhappy if you give it a keyring path that doesn't exist,
    # but is totally happy if that file is empty.  So ensure a file exists.
    keyring_file = os.path.join(USER_SANDSTORM_DIR, "sandstorm-keyring")
    if not os.path.exists(keyring_file):
        with open(keyring_file, "wb") as f:
            pass

def setup_vm(args):
    expected_stack_plugin = args.command_specific_args[0]
    if expected_stack_plugin not in STACK_PLUGINS:
        raise Exception("No stack plugin for {}".format(expected_stack_plugin))
    stack_plugin = STACK_PLUGINS[expected_stack_plugin]
    if "setup" not in stack_plugin or "launcher" not in stack_plugin:
        raise Exception("Stack plugins require both 'setup' and 'launcher' scripts.")

    sandstorm_dir = os.path.join(args.work_directory, ".sandstorm")
    print "Initializing .sandstorm directory in {}".format(sandstorm_dir)
    # Create .sandstorm directory
    if not os.path.isdir(sandstorm_dir):
        os.makedirs(sandstorm_dir, mode=0755)

    # Make sure ~/.sandstorm exists for storing signing keys
    ensure_host_sandstorm_folder_exists()

    # Copy global setup script to e.g. install and configure sandstorm
    with open(os.path.join(sandstorm_dir, "global-setup.sh"), "w") as f:
        f.write(GLOBAL_SETUP_SCRIPT)

    # Copy stack-specific script to e.g. install and configure nginx, mysql, and php5-fpm
    with open(os.path.join(sandstorm_dir, "setup.sh"), "w") as f:
        f.write(stack_plugin["setup"])

    # Copy build script, if present, to sandstorm root.  If none is provided by
    # this stack, add an empty one so that users can customize it if needed.
    build_script_path = os.path.join(sandstorm_dir, "build.sh")
    with open(build_script_path, "w") as f:
        if 'build' in stack_plugin:
            f.write(stack_plugin["build"])
        else:
            f.write(EMPTY_BUILD_SCRIPT)
    os.chmod(build_script_path, 0755)

    # Copy default launcher script to sandstorm root for spk tracking
    launcher_script_path = os.path.join(sandstorm_dir, "launcher.sh")
    with open(launcher_script_path, "w") as f:
        f.write(stack_plugin["launcher"])
    os.chmod(launcher_script_path, 0755)

    # Copy in Vagrantfile
    vagrantfile_path = os.path.join(sandstorm_dir, "Vagrantfile")
    with open(vagrantfile_path, "w") as f:
        f.write(VAGRANTFILE_CONTENTS)

def bring_up_vm(args):
    sandstorm_dir = os.path.join(args.work_directory, ".sandstorm")
    # Bring up VM
    call_vagrant_command(sandstorm_dir, "up")

def init(args):
    sandstorm_dir = os.path.join(args.work_directory, ".sandstorm")
    # Initialize the package with spk init
    call_vagrant_command(sandstorm_dir, "ssh", "-c", "spk init -p 8000 --keyring=/host-dot-sandstorm/sandstorm-keyring --output=/opt/app/.sandstorm/sandstorm-pkgdef.capnp -- /opt/app/.sandstorm/launcher.sh")

def dev(args):
    sandstorm_dir = os.path.join(args.work_directory, ".sandstorm")
    call_vagrant_command(sandstorm_dir, "ssh", "-c", " && ".join([
        "/opt/app/.sandstorm/build.sh",
        "cd /opt/app/.sandstorm",
        "spk dev --pkg-def=/opt/app/.sandstorm/sandstorm-pkgdef.capnp:pkgdef"
    ]))

def pack(args):
    output_spk = args.command_specific_args[0]
    print output_spk
    sandstorm_dir = os.path.join(args.work_directory, ".sandstorm")
    # spk doesn't like to build packages on the vboxsf filesystem due to some
    # oddity when you unlink an open file, so we build the package in the guest
    # homedir, then move it out to the host.
    call_vagrant_command(sandstorm_dir, "ssh", "-c", " && ".join([
        "cd /opt/app.sandstorm/",
        "spk pack --keyring=/host-dot-sandstorm/sandstorm-keyring --pkg-def=/opt/app/.sandstorm/sandstorm-pkgdef.capnp:pkgdef /home/vagrant/sandstorm-package.spk",
        "mv /home/vagrant/sandstorm-package.spk /opt/app/sandstorm-package.spk"
    ]))
    os.rename("sandstorm-package.spk", output_spk)
    print "package produced at {}".format(output_spk)

def halt(args):
    sandstorm_dir = os.path.join(args.work_directory, ".sandstorm")
    print call_vagrant_command(sandstorm_dir, "halt")

def destroy(args):
    sandstorm_dir = os.path.join(args.work_directory, ".sandstorm")
    print call_vagrant_command(sandstorm_dir, "destroy", "--force")

def wipe(args):
    destroy(args)
    sandstorm_dir = os.path.join(args.work_directory, ".sandstorm")
    shutil.rmtree(sandstorm_dir)

def ssh(args):
    sandstorm_dir = os.path.join(args.work_directory, ".sandstorm")
    call_vagrant_command(sandstorm_dir, "ssh")

def main():
    operations = {
            'setupvm': setup_vm,
            'up': bring_up_vm,
            'init': init,
            'dev': dev,
            'pack': pack,
            'halt': halt,
            'destroy': destroy,
            'wipe': wipe,
            'ssh': ssh,
    }
    parser = argparse.ArgumentParser(prog=sys.argv[0])
    parser.add_argument("command", choices=sorted(operations.keys()))
    parser.add_argument("command_specific_args", nargs="*")
    parser.add_argument("--work-directory", action='store', default=PWD)
    args = parser.parse_args(sys.argv[1:])
    operation = operations[args.command]
    operation(args)

if __name__ == "__main__":
    main()
