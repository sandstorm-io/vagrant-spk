#!/usr/bin/env python2.7
#   Copyright 2015 Drew Fisher (zarvox@zarvox.org)
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.

# Example usage:
# vagrant-spk setupvm lemp
# vagrant-spk up
# vagrant-spk init
# vagrant-spk dev
# vagrant-spk pack output.spk

from __future__ import print_function

import argparse
import os
import glob
import re
import shutil
import subprocess
import sys

PWD = os.getcwd()
ENABLE_EXPERIMENTAL = False
CODE_DIR = os.path.dirname(os.path.realpath(sys.argv[0]))
VAGRANTFILE_CONTENTS = r"""# -*- mode: ruby -*-
# vi: set ft=ruby :

# Guess at a reasonable name for the VM based on the folder vagrant-spk is
# run from.  The timestamp is there to avoid conflicts if you have multiple
# folders with the same name.
VM_NAME = File.basename(File.dirname(File.dirname(__FILE__))) + "_sandstorm_#{Time.now.utc.to_i}"

# Vagrantfile API/syntax version. Don't touch unless you know what you're doing!
VAGRANTFILE_API_VERSION = "2"

Vagrant.configure(VAGRANTFILE_API_VERSION) do |config|
  # We base ourselves off Debian Jessie
  config.vm.box = "debian/jessie64"
  # We pin to base box version 8.2.1 because 8.2.2 removes support for
  # vboxsf, aka VirtualBox file sharing.
  config.vm.box_version = "8.2.1"

  if Vagrant.has_plugin?("vagrant-vbguest") then
    # vagrant-vbguest is a Vagrant plugin that upgrades
    # the version of VirtualBox Guest Additions within each
    # guest. If you have the vagrant-vbguest plugin, then it
    # needs to know how to compile kernel modules, etc., and so
    # we give it this hint about operating system type.
    config.vm.guest = "debian"
  end

  # We forward port 6080, the Sandstorm web port, so that developers can
  # visit their sandstorm app from their browser as local.sandstorm.io:6080
  # (aka 127.0.0.1:6080).
  config.vm.network :forwarded_port, guest: 6080, host: 6080

  # Use a shell script to "provision" the box. This installs Sandstorm using
  # the bundled installer.
  config.vm.provision "shell", inline: "sudo bash /opt/app/.sandstorm/global-setup.sh", keep_color: true
  # Then, do stack-specific and app-specific setup.
  config.vm.provision "shell", inline: "sudo bash /opt/app/.sandstorm/setup.sh", keep_color: true

  # Shared folders are configured per-provider since vboxsf can't handle >4096 open files,
  # NFS requires privilege escalation every time you bring a VM up,
  # and 9p is only available on libvirt.

  # Calculate the number of CPUs and the amount of RAM the system has,
  # in a platform-dependent way; further logic below.
  cpus = nil
  total_kB_ram = nil

  host = RbConfig::CONFIG['host_os']
  if host =~ /darwin/
    cpus = `sysctl -n hw.ncpu`.to_i
    total_kB_ram =  `sysctl -n hw.memsize`.to_i / 1024
  elsif host =~ /linux/
    cpus = `nproc`.to_i
    total_kB_ram = `grep MemTotal /proc/meminfo | awk '{print $2}'`.to_i
  elsif host =~ /mingw/
    # powershell may not be available on Windows XP and Vista, so wrap this in a rescue block
    begin
      cpus = `powershell -Command "(Get-WmiObject Win32_Processor -Property NumberOfLogicalProcessors | Select-Object -Property NumberOfLogicalProcessors | Measure-Object NumberOfLogicalProcessors -Sum).Sum"`.to_i
      total_kB_ram = `powershell -Command "Get-CimInstance -class cim_physicalmemory | % $_.Capacity}"`.to_i / 1024
    rescue
    end
  end
  # Use the same number of CPUs within Vagrant as the system, with 1
  # as a default.
  #
  # Use at least 512MB of RAM, and if the system has more than 2GB of
  # RAM, use 1/4 of the system RAM. This seems a reasonable compromise
  # between having the Vagrant guest operating system not run out of
  # RAM entirely (which it basically would if we went much lower than
  # 512MB) and also allowing it to use up a healthily large amount of
  # RAM so it can run faster on systems that can afford it.
  if cpus.nil? or cpus.zero?
    cpus = 1
  end
  if total_kB_ram.nil? or total_kB_ram < 2048000
    assign_ram_mb = 512
  else
    assign_ram_mb = (total_kB_ram / 1024 / 4)
  end
  # Actually apply these CPU/memory values to the providers.
  config.vm.provider :virtualbox do |vb, override|
    vb.cpus = cpus
    vb.memory = assign_ram_mb
    vb.name = VM_NAME

    override.vm.synced_folder "..", "/opt/app"
    override.vm.synced_folder ENV["HOME"] + "/.sandstorm", "/host-dot-sandstorm"
    override.vm.synced_folder "..", "/vagrant"
  end
  config.vm.provider :libvirt do |libvirt, override|
    libvirt.cpus = cpus
    libvirt.memory = assign_ram_mb
    libvirt.default_prefix = VM_NAME

    override.vm.synced_folder "..", "/opt/app", type: "9p", accessmode: "passthrough"
    override.vm.synced_folder ENV["HOME"] + "/.sandstorm", "/host-dot-sandstorm", type: "9p", accessmode: "passthrough"
    override.vm.synced_folder "..", "/vagrant", type: "9p", accessmode: "passthrough"
  end
end
"""

GLOBAL_SETUP_SCRIPT = r"""#!/bin/bash
set -euo pipefail

CURL_OPTS="--silent --show-error"
echo localhost > /etc/hostname
hostname localhost
curl $CURL_OPTS https://install.sandstorm.io/ > /host-dot-sandstorm/caches/install.sh
SANDSTORM_CURRENT_VERSION=$(curl $CURL_OPTS -f "https://install.sandstorm.io/dev?from=0&type=install")
SANDSTORM_PACKAGE="sandstorm-$SANDSTORM_CURRENT_VERSION.tar.xz"
if [[ ! -f /host-dot-sandstorm/caches/$SANDSTORM_PACKAGE ]] ; then
    echo -n "Downloading Sandstorm version ${SANDSTORM_CURRENT_VERSION}..."
    curl $CURL_OPTS --output "/host-dot-sandstorm/caches/$SANDSTORM_PACKAGE.partial" "https://dl.sandstorm.io/$SANDSTORM_PACKAGE"
    mv "/host-dot-sandstorm/caches/$SANDSTORM_PACKAGE.partial" "/host-dot-sandstorm/caches/$SANDSTORM_PACKAGE"
    echo "...done."
fi
if [ ! -e /opt/sandstorm/latest/sandstorm ] ; then
    echo -n "Installing Sandstorm version ${SANDSTORM_CURRENT_VERSION}..."
    bash /host-dot-sandstorm/caches/install.sh -d -e "/host-dot-sandstorm/caches/$SANDSTORM_PACKAGE" >/dev/null
    echo "...done."
fi
modprobe ip_tables
# Make the vagrant user part of the sandstorm group so that commands like
# `spk dev` work.
usermod -a -G 'sandstorm' 'vagrant'
# Bind to all addresses, so the vagrant port-forward works.
sudo sed --in-place='' \
        --expression='s/^BIND_IP=.*/BIND_IP=0.0.0.0/' \
        /opt/sandstorm/sandstorm.conf
sudo service sandstorm restart
# Enable apt-cacher-ng proxy to make things faster if one appears to be running on the gateway IP
GATEWAY_IP=$(ip route  | grep ^default  | cut -d ' ' -f 3)
if nc -z "$GATEWAY_IP" 3142 ; then
    echo "Acquire::http::Proxy \"http://$GATEWAY_IP:3142\";" > /etc/apt/apt.conf.d/80httpproxy
fi
"""

EMPTY_BUILD_SCRIPT = r"""#!/bin/bash
set -euo pipefail
# This is a script that is run every time you call "vagrant-spk dev".
# It is intended to do platform-and-repository-specific build steps.  You
# might customize it to do any of the following, or more:
# - for Python, prepare a virtualenv and pip install -r requirements.txt
# - for PHP, call composer to retrieve additional packages
# - for JS/CSS/SASS/LESS, compile, minify, or otherwise do asset pipeline work.
# This particular script does nothing at present, but you should adapt it
# sensibly for your package.

exit 0
"""

def check_dot_sandstorm():
    expected_path = os.path.join(PWD, ".sandstorm")
    if not os.path.isdir(expected_path):
        raise Exception("expected to find a .sandstorm folder at {}".format(os.path.abspath(expected_path)))
    expected_vagrantfile_path = os.path.join(expected_path, "Vagrantfile")
    if not os.path.exists(expected_vagrantfile_path):
        raise Exception("expected a Vagrantfile at {} - try 'vagrant-spk setupvm lemp' to generate one".format(expected_vagrantfile_path))

def call_vagrant_command(sandstorm_dir, *command_args):
    command = ["vagrant"]
    command.extend(command_args)
    print("Calling {} in {}".format(" ".join(["'{}'".format(arg) for arg in command]), sandstorm_dir))
    return subprocess.check_call(command, cwd=sandstorm_dir)

def ensure_host_sandstorm_folder_exists():
    # We wrap the keyring in an additional folder, because Vagrant shared
    # folders can't share single files, only folders, and I don't want to give
    # the VM read/write access to the user's entire homedir, just the sandstorm
    # keyring.
    USER_SANDSTORM_DIR = os.path.join(os.path.expanduser("~"), ".sandstorm")
    if not os.path.exists(USER_SANDSTORM_DIR):
        print("Creating {} to hold developer keys.".format(USER_SANDSTORM_DIR))
        os.makedirs(USER_SANDSTORM_DIR)
    USER_SANDSTORM_CACHE_DIR = os.path.join(USER_SANDSTORM_DIR, "caches")
    if not os.path.exists(USER_SANDSTORM_CACHE_DIR):
        print("Creating {} to hold sandstorm installer caches.".format(USER_SANDSTORM_CACHE_DIR))
        os.makedirs(USER_SANDSTORM_CACHE_DIR)
    # Sandstorm is unhappy if you give it a keyring path that doesn't exist,
    # but is totally happy if that file is empty.  So ensure a file exists.
    keyring_file = os.path.join(USER_SANDSTORM_DIR, "sandstorm-keyring")
    if not os.path.exists(keyring_file):
        with open(keyring_file, "wb") as f:
            pass

class StackPlugin(object):
    def __init__(self, plugin_name):
        self._plugin_name = plugin_name
        plugin_dir = os.path.join(CODE_DIR, "stacks", self._plugin_name)
        if not os.path.exists(plugin_dir):
            raise Exception("No stack plugin for {}".format(plugin_name))
        if (not os.path.exists(os.path.join(plugin_dir, "setup.sh")) or
            not os.path.exists(os.path.join(plugin_dir, "launcher.sh"))):
            raise Exception("Stack plugins require both 'setup.sh' and 'launcher.sh' scripts.")

    def plugin_file(self, filename):
        return os.path.join(CODE_DIR, "stacks", self._plugin_name, filename)

    def init_args(self):
        args_file = os.path.join(CODE_DIR, "stacks", self._plugin_name, "initargs")
        if os.path.exists(args_file):
            with open(args_file) as f:
                return f.read().strip()
        else:
            return ""

def switch_to_https_cdn_resources(input_file_contents):
    # Let's change HTML with regular expressions. I realize that is a
    # dangerous thing to do, but I like to live dangerously (and
    # moreover we're changing Meteor templates so it's not like I can
    # "just" parse with a HTML parser and then serialize).
    changed = False
    input_output_pairs = (
        ('http://fonts.googleapis.com', 'https://fonts.googleapis.com'),
    )
    meta_regexes = [
        '''(href=")(%s)''',
        '''(href=')(%s)''',
    ]
    output = input_file_contents

    for (bad, good) in input_output_pairs:
        for regex in meta_regexes:
            replacer_function = lambda matches: (matches.group(1) + good)
            output = re.sub(regex % (bad,), replacer_function, output)

    return output


def auto(args):
    # Automatic packaging. This assumes:
    #
    # - There is no .sandstorm/ yet, and
    #
    # - The app uses git, and
    #
    # - It is OK to create a package with a key (package ID) that will
    #   get lost, and
    #
    # - The user knows how to install the result on a Sandstorm
    #   install.

    # Ensure this directory has a .meteor/. If not, bail out early and ask
    # the user to "cd" into a directory that does.
    stack = None
    STACK_TYPE_METEOR = 'meteor'
    if args.command_specific_args[0] == 'meteor':
        stack = STACK_TYPE_METEOR

    if stack == STACK_TYPE_METEOR:
        if not os.path.exists('.meteor'):
            print("ERROR", "Automatic packaging cannot proceed since you are not in a meteor project.")
            print("You will have to `cd` into another directory before running this too.")
            glob_matches = glob.glob('*/.meteor')
            if glob_matches:
                print('')
                print('Try running: cd', glob_matches[0][:-len('.meteor')])
            sys.exit(1)

    # If this is a Meteor app, modify the app:
    #
    # - Add the Sandstorm accounts package, for auto-sign-in.
    #
    # - Maybe in the future, fix HTTP/HTTPS mixed content stuff on
    #   common CDN domains. Note that the real fix for this is to
    #   embed a copy of the assets in the app package, but this works
    #   for now.
    if stack == STACK_TYPE_METEOR:
        ACCOUNTS_PKG = 'kenton:accounts-sandstorm'
        if ACCOUNTS_PKG not in open('.meteor/packages').read():
            with open('.meteor/packages', 'a') as fd:
                fd.write('\n')
                fd.write(ACCOUNTS_PKG)
                fd.write('\n')

        # We can use `git`, so let's use it to loop over the files
        # in the repo and search for well-known HTTP resource links,
        # replacing them with HTTPS resource links.
        git_ls_files_executor = subprocess.Popen(['git', 'ls-files', '--', '*.html'],
                                                 stdout=subprocess.PIPE)
        exit_code = git_ls_files_executor.wait()
        assert exit_code == 0
        stdout = git_ls_files_executor.communicate()[0]
        for filename in stdout.split('\n'):
            filename = filename.strip()
            if not filename:
                continue
            with open(filename, 'r') as fd:
                original_text = fd.read()
            https_ified = switch_to_https_cdn_resources(original_text)
            if https_ified != original_text:
                print('** Converting', filename, 'to HTTPS resources.')
                with open(filename, 'w') as fd:
                    fd.write(https_ified)

    # setupvm
    print('$', 'vagrant-spk setup', ' '.join(args.command_specific_args))
    setup_vm(args)

    # Remove any command-specific args for now.
    args.command_specific_args = []

    # up
    print('$', 'vagrant-spk up')
    bring_up_vm(args)

    # init. This stores a fresh private key.
    print('$', 'vagrant-spk init')
    init(args)

    # Modify the .sandstorm/sandstorm-pkgdef.capnp to contain
    # the git repo name in some way, if there is a git repo here.
    git_repo = None
    git_remote_executor = subprocess.Popen(['git', 'remote', '-v'], stdout=subprocess.PIPE)
    exit_code = git_remote_executor.wait()
    if exit_code == 0:
        stdout = git_remote_executor.communicate()[0]
        git_repo = stdout.split('\n')[0].split()[1]

    if git_repo is not None:
        with open('.sandstorm/sandstorm-pkgdef.capnp') as fd:
            orig_capnp = fd.read()

        # Fix codeUrl =
        assert 'codeUrl = "http://example.com",' in orig_capnp
        improved_capnp = orig_capnp.replace(
            'codeUrl = "http://example.com",',
            'codeUrl = "{0}",'.format(git_repo))

        # Fix appTitle =
        nicertitle = git_repo.split('/')[-1]
        assert '(defaultText = "Example App")' in orig_capnp
        improved_capnp = improved_capnp.replace(
            '(defaultText = "Example App")',
            '(defaultText = "{0}")'.format(nicertitle))

        with open('.sandstorm/sandstorm-pkgdef.capnp', 'w') as fd:
            fd.write(improved_capnp)

    # Run build, but skip spk dev. TODO make less hacky.
    # Skip dev mode, since this is non-interactive for now.
    print('$', 'vagrant-spk dev')
    sandstorm_dir = os.path.join(args.work_directory, ".sandstorm")
    call_vagrant_command(sandstorm_dir, "ssh", "-c", " && ".join([
        "/opt/app/.sandstorm/build.sh",
    ]))

    print("*** Click around and make sure the app works OK ***")

    # TODO: Replace 'Example app' with 'Fantastic app'.

    # Package it.
    args.command_specific_args = ['../app.spk']
    print('$', 'vagrant-spk pack', ' '.join(args.command_specific_args))
    pack(args)
    args.command_specific_args = []

    # Success. Bring down the VM for now, since otherwise port 6080
    # will be in use.
    print('')
    print('You can run:')
    print('$ vagrant-spk halt')
    print('')
    print('When you are ready to stop thinking about packaging this app.')


def setup_vm(args):
    stack_plugin_name = args.command_specific_args[0]
    stack_plugin = StackPlugin(stack_plugin_name)
    sandstorm_dir = os.path.join(args.work_directory, ".sandstorm")
    print("Initializing .sandstorm directory in {}".format(sandstorm_dir))
    # Create .sandstorm directory
    if not os.path.isdir(sandstorm_dir):
        os.makedirs(sandstorm_dir, mode=0o755)

    # Make sure ~/.sandstorm exists for storing signing keys
    ensure_host_sandstorm_folder_exists()

    # Copy global setup script to e.g. install and configure sandstorm
    global_setup_script_path = os.path.join(sandstorm_dir, "global-setup.sh")
    with open(global_setup_script_path, "wb") as f:
        f.write(GLOBAL_SETUP_SCRIPT)
    os.chmod(global_setup_script_path, 0o755)

    # Copy stack-specific script to e.g. install and configure nginx, mysql, and php5-fpm
    setup_script_path = os.path.join(sandstorm_dir, "setup.sh")
    with open(setup_script_path, "wb") as f:
        with open(stack_plugin.plugin_file("setup.sh"), "rb") as g:
            f.write(g.read())
    os.chmod(setup_script_path, 0o755)

    # Copy build script, if present, to sandstorm root.  If none is provided by
    # this stack, add an empty one so that users can customize it if needed.
    build_script_path = os.path.join(sandstorm_dir, "build.sh")
    with open(build_script_path, "wb") as f:
        source_script_path = stack_plugin.plugin_file("build.sh")
        if os.path.exists(source_script_path):
            with open(source_script_path, "rb") as g:
                f.write(g.read())
        else:
            f.write(EMPTY_BUILD_SCRIPT)
    os.chmod(build_script_path, 0o755)

    # Copy default launcher script to sandstorm root for spk tracking
    launcher_script_path = os.path.join(sandstorm_dir, "launcher.sh")
    with open(launcher_script_path, "wb") as f:
        with open(stack_plugin.plugin_file("launcher.sh")) as g:
            f.write(g.read())
    os.chmod(launcher_script_path, 0o755)

    # Copy in Vagrantfile
    vagrantfile_path = os.path.join(sandstorm_dir, "Vagrantfile")
    with open(vagrantfile_path, "w") as f:
        f.write(VAGRANTFILE_CONTENTS)

    # Make a note of which stack was used
    stack_path = os.path.join(sandstorm_dir, "stack")
    with open(stack_path, "w") as f:
        f.write(stack_plugin_name + "\n")

def bring_up_vm(args):
    sandstorm_dir = os.path.join(args.work_directory, ".sandstorm")
    # Make sure ~/.sandstorm exists, since global-setup.sh uses
    # ~/.sandstorm/caches to cache the installers
    ensure_host_sandstorm_folder_exists()
    # Bring up VM
    call_vagrant_command(sandstorm_dir, "up")

def init(args):
    sandstorm_dir = os.path.join(args.work_directory, ".sandstorm")
    # Figure out which stack created this runtime, so we can load appropriate additional init args.
    stack_path = os.path.join(sandstorm_dir, "stack")
    with open(stack_path) as f:
        stack = f.read().strip()
    stack_plugin = StackPlugin(stack)
    init_args = stack_plugin.init_args()
    # Initialize the package with spk init
    call_vagrant_command(sandstorm_dir, "ssh", "-c", "spk init -p 8000 --keyring=/host-dot-sandstorm/sandstorm-keyring --output=/opt/app/.sandstorm/sandstorm-pkgdef.capnp {} -- /opt/app/.sandstorm/launcher.sh".format(init_args))

def dev(args):
    sandstorm_dir = os.path.join(args.work_directory, ".sandstorm")
    call_vagrant_command(sandstorm_dir, "ssh", "-c", " && ".join([
        "/opt/app/.sandstorm/build.sh",
        "cd /opt/app/.sandstorm",
        "spk dev --pkg-def=/opt/app/.sandstorm/sandstorm-pkgdef.capnp:pkgdef"
    ]))

def pack(args):
    output_spk = args.command_specific_args[0]
    print(output_spk)
    sandstorm_dir = os.path.join(args.work_directory, ".sandstorm")
    # spk doesn't like to build packages on the vboxsf filesystem due to some
    # oddity when you unlink an open file, so we build the package in the guest
    # homedir, then move it out to the host.
    call_vagrant_command(sandstorm_dir, "ssh", "-c", " && ".join([
        "cd /opt/app/.sandstorm/",
        "spk pack --keyring=/host-dot-sandstorm/sandstorm-keyring --pkg-def=/opt/app/.sandstorm/sandstorm-pkgdef.capnp:pkgdef /home/vagrant/sandstorm-package.spk",
        "mv /home/vagrant/sandstorm-package.spk /opt/app/sandstorm-package.spk"
    ]))
    os.rename("sandstorm-package.spk", output_spk)
    print("package produced at {}".format(output_spk))

def publish(args):
    # Sadly, we have to copy the spk into the VM since it could be anywhere on the host filesystem
    spk = args.command_specific_args[0]
    sandstorm_dir = os.path.join(args.work_directory, ".sandstorm")
    spk_basename = os.path.basename(spk)
    temp_spk = os.path.join(sandstorm_dir, spk_basename)

    try:
        shutil.copyfile(spk, temp_spk)
        call_vagrant_command(sandstorm_dir, "ssh", "-c", "spk publish --keyring=/host-dot-sandstorm/sandstorm-keyring /opt/app/.sandstorm/{}".format(spk_basename))
    finally:
        os.remove(temp_spk)

def halt(args):
    sandstorm_dir = os.path.join(args.work_directory, ".sandstorm")
    call_vagrant_command(sandstorm_dir, "halt")

def destroy(args):
    sandstorm_dir = os.path.join(args.work_directory, ".sandstorm")
    call_vagrant_command(sandstorm_dir, "destroy", "--force")

def global_status(args):
    return subprocess.check_call(["vagrant", "global-status"])

def ssh(args):
    sandstorm_dir = os.path.join(args.work_directory, ".sandstorm")
    call_vagrant_command(sandstorm_dir, "ssh")

def main():
    global ENABLE_EXPERIMENTAL
    # Switch on feature(s) that we don't think are ready for everyone.
    if os.environ.get("VAGRANT_SPK_EXPERIMENTAL", "").upper() == "Y":
        ENABLE_EXPERIMENTAL = True

    operations = [
        ('setupvm', setup_vm,
            "Set up a fresh app environment in \n"
            "  --work-directory (using the provided `stack` \n"
            "  command arg).  Also inits developer keys in \n"
            "  ~/.sandstorm on this host."),
        ('up', bring_up_vm,
            "Start the Vagrant VM (and build the VM image \n"
            "  if necessary)."),
        ('init', init,
            "Initialize fresh Sandstorm package definition \n"
            "  resources in --work-directory."),
        ('dev', dev,
            "Make the current app available to Sandstorm \n"
            "  in dev mode (after bringing the Vagrant VM `up`)"),
        ('pack', pack,
            "Pack the curent app into a \n"
            "  Sandstorm package."),
        ('publish', publish,
            "Send the current packed app spk to \n"
            "  the Sandstorm App Market."),
        ('halt', halt,
            "Shut down the Vagrant VM."),
        ('destroy', destroy,
            "Delete the Vagrant VM (but leave \n"
            "  --work-directory untouched)."),
        ('global-status', global_status,
            "Show the state of all active \n"
            "  Vagrant VMs on this host."),
        ('ssh', ssh,
            "SSH into the Vagrant VM."),
    ]

    if ENABLE_EXPERIMENTAL:
        operations.append(
            ('auto', auto,
             "Automatically package the app in \n"
             "  --work-directory (using the provided `stack` \n"
             "  command arg. Also inits developer keys in \n"
             "  ~/.sandstorm on this host. (EXPERIMENTAL)"))

    op_to_func = dict((cmd, f) for cmd, f, helptext in operations)
    ops_helptext = '\n'.join(cmd + ': ' + helptext for cmd, f, helptext in operations)
    parser = argparse.ArgumentParser(prog=sys.argv[0], formatter_class=argparse.RawTextHelpFormatter)
    parser.add_argument("command", choices=[cmd for cmd, _, _ in operations], help=ops_helptext)
    parser.add_argument("command_specific_args", nargs="*")
    parser.add_argument(
        "--work-directory",
        action='store',
        default=PWD,
        help="Use this working directory (e.g. for .sandstorm/ \n"
             "and other configuration).  [Default: current \n"
             "working directory]")
    args = parser.parse_args(sys.argv[1:])
    operation = op_to_func[args.command]
    operation(args)

if __name__ == "__main__":
    main()
