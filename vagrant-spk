#!/usr/bin/env python2.7
#   Copyright 2015-2018 Sandstorm Development Group, Inc. and contributors
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.

# Example usage:
# vagrant-spk setupvm lemp
# vagrant-spk vm up
# vagrant-spk init
# vagrant-spk dev
# vagrant-spk pack output.spk

from __future__ import print_function

# TODO(someday): Increment version number and commit as part of release.sh
__version__ = "v0.236"

import argparse
import os
import glob
import hashlib
import re
import shutil
import subprocess
import sys

PWD = os.getcwd()
ENABLE_EXPERIMENTAL = False

EXECUTABLE_PATH = os.path.realpath(sys.argv[0])

# When run as bundled by pyinstaller, sys.argv[0] is simply "vagrant-spk".
# os.path.realpath("vagrant-spk") will produce a path in the current working directory, which
# probably doesn't actually exist, and definitely doesn't contain the "stacks" folder that we
# expect to find in the same folder as the executable.  So in that environment, use
# sys.executable to find the folder the program is running from.
# When run not bundled, sys.executable is something like /usr/bin/python, so only try this
# if sys.argv[0] doesn't appear to be an actual living file.
if not os.path.exists(EXECUTABLE_PATH):
    EXECUTABLE_PATH = sys.executable
CODE_DIR = os.path.dirname(EXECUTABLE_PATH)

VAGRANTFILE_CONTENTS = r"""# -*- mode: ruby -*-
# vi: set ft=ruby :

# Guess at a reasonable name for the VM based on the folder vagrant-spk is
# run from.  The timestamp is there to avoid conflicts if you have multiple
# folders with the same name.
VM_NAME = File.basename(File.dirname(File.dirname(__FILE__))) + "_sandstorm_#{Time.now.utc.to_i}"

# Vagrantfile API/syntax version. Don't touch unless you know what you're doing!
VAGRANTFILE_API_VERSION = "2"

# ugly hack to prevent hashicorp's bitrot. See https://github.com/hashicorp/vagrant/issues/9442
# this setting is required for pre-2.0 vagrant, but causes an error as of 2.0.3,
# remove entirely when confident nobody uses vagrant 1.x for anything.
unless Vagrant::DEFAULT_SERVER_URL.frozen?
  Vagrant::DEFAULT_SERVER_URL.replace('https://vagrantcloud.com')
end

Vagrant.configure(VAGRANTFILE_API_VERSION) do |config|
  # Base on the Sandstorm snapshots of the official Debian 9 (stretch) box with vboxsf support.
  config.vm.box = "debian/contrib-stretch64"
  config.vm.box_version = "9.3.0"

  if Vagrant.has_plugin?("vagrant-vbguest") then
    # vagrant-vbguest is a Vagrant plugin that upgrades
    # the version of VirtualBox Guest Additions within each
    # guest. If you have the vagrant-vbguest plugin, then it
    # needs to know how to compile kernel modules, etc., and so
    # we give it this hint about operating system type.
    config.vm.guest = "debian"
  end

  # We forward port 6080, the Sandstorm web port, so that developers can
  # visit their sandstorm app from their browser as local.sandstorm.io:6080
  # (aka 127.0.0.1:6080).
  config.vm.network :forwarded_port, guest: 6080, host: 6080, host_ip: "127.0.0.1"

  # Use a shell script to "provision" the box. This installs Sandstorm using
  # the bundled installer.
  config.vm.provision "shell", inline: "sudo bash /opt/app/.sandstorm/global-setup.sh", keep_color: true
  # Then, do stack-specific and app-specific setup.
  config.vm.provision "shell", inline: "sudo bash /opt/app/.sandstorm/setup.sh", keep_color: true

  # Shared folders are configured per-provider since vboxsf can't handle >4096 open files,
  # NFS requires privilege escalation every time you bring a VM up,
  # and 9p is only available on libvirt.

  # Calculate the number of CPUs and the amount of RAM the system has,
  # in a platform-dependent way; further logic below.
  cpus = nil
  total_kB_ram = nil

  host = RbConfig::CONFIG['host_os']
  if host =~ /darwin/
    cpus = `sysctl -n hw.ncpu`.to_i
    total_kB_ram =  `sysctl -n hw.memsize`.to_i / 1024
  elsif host =~ /linux/
    cpus = `nproc`.to_i
    total_kB_ram = `grep MemTotal /proc/meminfo | awk '{print $2}'`.to_i
  elsif host =~ /mingw/
    # powershell may not be available on Windows XP and Vista, so wrap this in a rescue block
    begin
      cpus = `powershell -Command "(Get-WmiObject Win32_Processor -Property NumberOfLogicalProcessors | Select-Object -Property NumberOfLogicalProcessors | Measure-Object NumberOfLogicalProcessors -Sum).Sum"`.to_i
      total_kB_ram = `powershell -Command "Get-CimInstance -class cim_physicalmemory | % $_.Capacity"`.to_i / 1024
    rescue
    end
  end
  # Use the same number of CPUs within Vagrant as the system, with 1
  # as a default.
  #
  # Use at least 512MB of RAM, and if the system has more than 2GB of
  # RAM, use 1/4 of the system RAM. This seems a reasonable compromise
  # between having the Vagrant guest operating system not run out of
  # RAM entirely (which it basically would if we went much lower than
  # 512MB) and also allowing it to use up a healthily large amount of
  # RAM so it can run faster on systems that can afford it.
  if cpus.nil? or cpus.zero?
    cpus = 1
  end
  if total_kB_ram.nil? or total_kB_ram < 2048000
    assign_ram_mb = 512
  else
    assign_ram_mb = (total_kB_ram / 1024 / 4)
  end
  # Actually apply these CPU/memory values to the providers.
  config.vm.provider :virtualbox do |vb, override|
    vb.cpus = cpus
    vb.memory = assign_ram_mb
    vb.name = VM_NAME
    vb.customize ["modifyvm", :id, "--nictype1", "Am79C973"]

    # /opt/app and /host-dot-sandstorm are used by vagrant-spk
    override.vm.synced_folder "..", "/opt/app"
    override.vm.synced_folder ENV["HOME"] + "/.sandstorm", "/host-dot-sandstorm"
    # /vagrant is not used by vagrant-spk; we need this line so it gets disabled; if we removed the
    # line, vagrant would automatically insert a synced folder in /vagrant, which is not what we want.
    override.vm.synced_folder "..", "/vagrant", disabled: true
  end
  config.vm.provider :libvirt do |libvirt, override|
    libvirt.cpus = cpus
    libvirt.memory = assign_ram_mb
    libvirt.default_prefix = VM_NAME

    # /opt/app and /host-dot-sandstorm are used by vagrant-spk
    override.vm.synced_folder "..", "/opt/app", type: "9p", accessmode: "passthrough"
    override.vm.synced_folder ENV["HOME"] + "/.sandstorm", "/host-dot-sandstorm", type: "9p", accessmode: "passthrough"
    # /vagrant is not used by vagrant-spk; we need this line so it gets disabled; if we removed the
    # line, vagrant would automatically insert a synced folder in /vagrant, which is not what we want.
    override.vm.synced_folder "..", "/vagrant", type: "9p", accessmode: "passthrough", disabled: true
  end
end
"""

GITATTRIBUTES_CONTENTS = r"""

# vagrant-spk creates shell scripts, which must end in \n, even on a \r\n system.
*.sh text eol=lf

"""

GITIGNORE_CONTENTS = r"""

# This file stores a list of sub-paths of .sandstorm/ that should be ignored by git.
.vagrant

"""

GLOBAL_SETUP_SCRIPT = r"""#!/bin/bash
set -euo pipefail

# Set options for curl. Since we only want to show errors from these curl commands, we also use
# 'cat' to buffer the output; for more information:
# https://github.com/sandstorm-io/vagrant-spk/issues/158

CURL_OPTS="--silent --show-error"
echo localhost > /etc/hostname
hostname localhost

# Install curl that is needed below.
apt-get update
apt-get install -y curl

# The following line copies stderr through stderr to cat without accidentally leaving it in the
# output file. Be careful when changing. See: https://github.com/sandstorm-io/vagrant-spk/pull/159
curl $CURL_OPTS https://install.sandstorm.io/ 2>&1 > /host-dot-sandstorm/caches/install.sh | cat

SANDSTORM_CURRENT_VERSION=$(curl $CURL_OPTS -f "https://install.sandstorm.io/dev?from=0&type=install")
SANDSTORM_PACKAGE="sandstorm-$SANDSTORM_CURRENT_VERSION.tar.xz"
if [[ ! -f /host-dot-sandstorm/caches/$SANDSTORM_PACKAGE ]] ; then
    echo -n "Downloading Sandstorm version ${SANDSTORM_CURRENT_VERSION}..."
    curl $CURL_OPTS --output "/host-dot-sandstorm/caches/$SANDSTORM_PACKAGE.partial" "https://dl.sandstorm.io/$SANDSTORM_PACKAGE" 2>&1 | cat
    mv "/host-dot-sandstorm/caches/$SANDSTORM_PACKAGE.partial" "/host-dot-sandstorm/caches/$SANDSTORM_PACKAGE"
    echo "...done."
fi
if [ ! -e /opt/sandstorm/latest/sandstorm ] ; then
    echo -n "Installing Sandstorm version ${SANDSTORM_CURRENT_VERSION}..."
    bash /host-dot-sandstorm/caches/install.sh -d -e "/host-dot-sandstorm/caches/$SANDSTORM_PACKAGE" >/dev/null
    echo "...done."
fi
modprobe ip_tables
# Make the vagrant user part of the sandstorm group so that commands like
# `spk dev` work.
usermod -a -G 'sandstorm' 'vagrant'
# Bind to all addresses, so the vagrant port-forward works.
sudo sed --in-place='' \
        --expression='s/^BIND_IP=.*/BIND_IP=0.0.0.0/' \
        /opt/sandstorm/sandstorm.conf
sudo service sandstorm restart
# Enable apt-cacher-ng proxy to make things faster if one appears to be running on the gateway IP
GATEWAY_IP=$(ip route  | grep ^default  | cut -d ' ' -f 3)
if nc -z "$GATEWAY_IP" 3142 ; then
    echo "Acquire::http::Proxy \"http://$GATEWAY_IP:3142\";" > /etc/apt/apt.conf.d/80httpproxy
fi
# Configure apt to retry fetching things that fail to download.
echo "APT::Acquire::Retries \"10\";" > /etc/apt/apt.conf.d/80sandstorm-retry
"""

EMPTY_BUILD_SCRIPT = r"""#!/bin/bash
set -euo pipefail
# This is a script that is run every time you call "vagrant-spk dev".
# It is intended to do platform-and-repository-specific build steps.  You
# might customize it to do any of the following, or more:
# - for Python, prepare a virtualenv and pip install -r requirements.txt
# - for PHP, call composer to retrieve additional packages
# - for JS/CSS/SASS/LESS, compile, minify, or otherwise do asset pipeline work.
# This particular script does nothing at present, but you should adapt it
# sensibly for your package.

exit 0
"""

def format_shell_grain_choices(supervisors):
    '''Return a formatted message based on the list of supervisor PIDs that were found, asking which
    grain the user wants to attach a shell to.'''

    assert supervisors  # caller is supposed to bail out for us if this is empty
    msg = (
'''This will run a shell in the context of a grain. Here is a list of running
grains you can attach to. Press enter to choose the first one, or type the
number next to the grain ID to choose it.''' + '\n\n')
    for i, datum in enumerate(supervisors):
        human_printable_i = i + 1
        msg += "{}. {}\n".format(
            human_printable_i, datum['grain_id'])
    msg += '\n'
    msg += 'Your choice: [1] '
    return msg

def check_dot_sandstorm():
    expected_path = os.path.join(PWD, ".sandstorm")
    if not os.path.isdir(expected_path):
        raise Exception("expected to find a .sandstorm folder at {}".format(os.path.abspath(expected_path)))
    expected_vagrantfile_path = os.path.join(expected_path, "Vagrantfile")
    if not os.path.exists(expected_vagrantfile_path):
        raise Exception("expected a Vagrantfile at {} - try 'vagrant-spk setupvm lemp' to generate one".format(expected_vagrantfile_path))

def call_vagrant_ssh_command_capturing_output(sandstorm_dir,
                                              vagrant_ssh_command_string,
                                              assert_exit_success=True):
    argv = ['vagrant', 'ssh', '-c', vagrant_ssh_command_string]
    p = subprocess.Popen(argv,
                         stdout=subprocess.PIPE,
                         stdin=subprocess.PIPE,
                         cwd=sandstorm_dir)
    out, err = p.communicate()
    # Ignore stderr, since it contains the vagrant output line of "Connection closed"
    # and our commands work via stdout anyway.
    if assert_exit_success:
        if p.returncode != 0:
            raise ValueError("Yikes, the command crashed. Command was: %s",
                             vagrant_ssh_command_string)
    return out


def call_vagrant_ssh_command_providing_stdin(sandstorm_dir,
                                             vagrant_ssh_command_string,
                                             stdin,
                                             assert_exit_success=True):
    p = subprocess.Popen(['vagrant', 'ssh', '-c', vagrant_ssh_command_string],
                         stdout=subprocess.PIPE,
                         stdin=subprocess.PIPE,
                         cwd=sandstorm_dir)
    out, err = p.communicate(input=stdin)
    # Ignore stderr, since it contains the vagrant output line of "Connection closed"
    # and our commands work via stdout anyway.
    if assert_exit_success:
        if p.returncode != 0:
            raise ValueError("Yikes, the command crashed. Command was: %s",
                             vagrant_ssh_command_string)
    return out


def call_vagrant_command(sandstorm_dir, *command_args):
    command = ["vagrant"]
    command.extend(command_args)
    sys.stderr.write("Calling {} in {}\n".format(" ".join(["'{}'".format(arg) for arg in command]), sandstorm_dir))
    try:
        return subprocess.check_call(command, cwd=sandstorm_dir)
    except subprocess.CalledProcessError as e:
        ANSI_RED = "\x1b[31m"
        ANSI_RESET = "\x1b[0m"
        msg = "Command failed with a non-zero exit status (%d)." % e.returncode
        sys.exit(ANSI_RED + msg + ANSI_RESET)

def ensure_working_vboxsf_in_base_box(sandstorm_dir):
    # If the .sandstorm/Vagrantfile refers to debian/jessie64, and does not pin it to a particular
    # version, and the user has version 8.2.2 available on their system, then we abort the
    # "vagrant-spk up" process because it will not work.
    def test_vagrantfile_refers_to_jessie64():
        with open(os.path.join(sandstorm_dir, 'Vagrantfile'), 'r') as fd:
            for line in fd:
                if line.strip().split() == 'config.vm.box = "debian/jessie64"'.split():
                    return True
        return False
    vagrantfile_refers_to_jessie64 = test_vagrantfile_refers_to_jessie64()

    def test_vagrantfile_pins_version():
        with open(os.path.join(sandstorm_dir, 'Vagrantfile'), 'r') as fd:
            for line in fd:
                if line.strip().startswith('config.vm.box_version'):
                    return True
        return False
    vagrantfile_pins_version = test_vagrantfile_pins_version()

    def get_vagrant_dot_d_path():
        if os.environ.get('VAGRANT_HOME'):
            return os.environ.get('VAGRANT_HOME')
        homedir = (os.environ.get('USERPROFILE') or os.environ.get('HOME'))
        return os.path.join(homedir, '.vagrant.d')
    user_has_version_822 = (os.path.exists(
        os.path.join(get_vagrant_dot_d_path(), 'boxes/debian-VAGRANTSLASH-jessie64/8.2.2')))

    if (vagrantfile_refers_to_jessie64 and
            (not vagrantfile_pins_version) and
            user_has_version_822):
        msg = (
            """*** INCOMPATIBLE OPTIONS DETECTED ***

You need to adjust .sandstorm/Vagrantfile due to recent incompatible changes
made by a project we depend on. Apologies for this mess.

Here's how to fix it:

Open .sandstorm/Vagrantfile and find this line:

  config.vm.box = "debian/jessie64"

Change it to:

  config.vm.box = "sandstorm/debian-jessie64"

For details (including how to bypass this warning) read:
https://github.com/sandstorm-io/vagrant-spk/releases/tag/v0.137

Once you have done that, please re-run this command ("vagrant-spk up").""")
        should_bail = True

        # If the VAGRANT_SPK_IGNORE_WARNINGS environment variable contains "jessie64", then
        # proceed anyway.
        if ('jessie64' in os.environ.get('VAGRANT_SPK_IGNORE_WARNINGS', '').split()):
            msg = '''*** INCOMPATIBLE OPTIONS DETECTED ***
    See https://github.com/sandstorm-io/vagrant-spk/releases/tag/v0.136
    Proceeding anyway due to VAGRANT_SPK_IGNORE_WARNINGS=jessie64...
'''
            should_bail = False

        print(msg)
        if should_bail:
            sys.exit(1)

def ensure_host_sandstorm_folder_exists():
    # We wrap the keyring in an additional folder, because Vagrant shared
    # folders can't share single files, only folders, and I don't want to give
    # the VM read/write access to the user's entire homedir, just the sandstorm
    # keyring.
    USER_SANDSTORM_DIR = os.path.join(os.path.expanduser("~"), ".sandstorm")
    if not os.path.exists(USER_SANDSTORM_DIR):
        print("Creating {} to hold developer keys.".format(USER_SANDSTORM_DIR))
        os.makedirs(USER_SANDSTORM_DIR)
    USER_SANDSTORM_CACHE_DIR = os.path.join(USER_SANDSTORM_DIR, "caches")
    if not os.path.exists(USER_SANDSTORM_CACHE_DIR):
        print("Creating {} to hold sandstorm installer caches.".format(USER_SANDSTORM_CACHE_DIR))
        os.makedirs(USER_SANDSTORM_CACHE_DIR)
    # Sandstorm is unhappy if you give it a keyring path that doesn't exist,
    # but is totally happy if that file is empty.  So ensure a file exists.
    keyring_file = os.path.join(USER_SANDSTORM_DIR, "sandstorm-keyring")
    if not os.path.exists(keyring_file):
        with open(keyring_file, "wb") as f:
            pass

class StackPlugin(object):
    def __init__(self, plugin_name):
        self._plugin_name = plugin_name
        plugin_dir = os.path.join(CODE_DIR, "stacks", self._plugin_name)
        if not os.path.exists(plugin_dir):
            raise Exception("No stack plugin for {}".format(plugin_name))
        if (not os.path.exists(os.path.join(plugin_dir, "setup.sh")) or
            not os.path.exists(os.path.join(plugin_dir, "launcher.sh"))):
            raise Exception("Stack plugins require both 'setup.sh' and 'launcher.sh' scripts.")

    def plugin_file(self, filename):
        return os.path.join(CODE_DIR, "stacks", self._plugin_name, filename)

    def init_args(self):
        args_file = os.path.join(CODE_DIR, "stacks", self._plugin_name, "initargs")
        if os.path.exists(args_file):
            with open(args_file) as f:
                return f.read().strip()
        else:
            return ""

def switch_to_https_cdn_resources(input_file_contents):
    # Let's change HTML with regular expressions. I realize that is a
    # dangerous thing to do, but I like to live dangerously (and
    # moreover we're changing Meteor templates so it's not like I can
    # "just" parse with a HTML parser and then serialize).
    changed = False
    input_output_pairs = (
        ('http://fonts.googleapis.com', 'https://fonts.googleapis.com'),
    )
    meta_regexes = [
        '''(href=")(%s)''',
        '''(href=')(%s)''',
    ]
    output = input_file_contents

    for (bad, good) in input_output_pairs:
        for regex in meta_regexes:
            replacer_function = lambda matches: (matches.group(1) + good)
            output = re.sub(regex % (bad,), replacer_function, output)

    return output


def auto(args):
    # Automatic packaging. This assumes:
    #
    # - There is no .sandstorm/ yet, and
    #
    # - The app uses git, and
    #
    # - It is OK to create a package with a key (package ID) that will
    #   get lost, and
    #
    # - The user knows how to install the result on a Sandstorm
    #   install.

    # Ensure this directory has a .meteor/. If not, bail out early and ask
    # the user to "cd" into a directory that does.
    stack = None
    STACK_TYPE_METEOR = 'meteor'
    if args.command_specific_args[0] == 'meteor':
        stack = STACK_TYPE_METEOR

    if stack == STACK_TYPE_METEOR:
        if not os.path.exists('.meteor'):
            print("ERROR", "Automatic packaging cannot proceed since you are not in a meteor project.")
            print("You will have to `cd` into another directory before running this too.")
            glob_matches = glob.glob('*/.meteor')
            if glob_matches:
                print('')
                print('Try running: cd', glob_matches[0][:-len('.meteor')])
            sys.exit(1)

    # If this is a Meteor app, modify the app:
    #
    # - Add the Sandstorm accounts package, for auto-sign-in.
    #
    # - Maybe in the future, fix HTTP/HTTPS mixed content stuff on
    #   common CDN domains. Note that the real fix for this is to
    #   embed a copy of the assets in the app package, but this works
    #   for now.
    if stack == STACK_TYPE_METEOR:
        ACCOUNTS_PKG = 'kenton:accounts-sandstorm'
        if ACCOUNTS_PKG not in open('.meteor/packages').read():
            with open('.meteor/packages', 'a') as fd:
                fd.write('\n')
                fd.write(ACCOUNTS_PKG)
                fd.write('\n')

        # We can use `git`, so let's use it to loop over the files
        # in the repo and search for well-known HTTP resource links,
        # replacing them with HTTPS resource links.
        git_ls_files_executor = subprocess.Popen(['git', 'ls-files', '--', '*.html'],
                                                 stdout=subprocess.PIPE)
        exit_code = git_ls_files_executor.wait()
        assert exit_code == 0
        stdout = git_ls_files_executor.communicate()[0]
        for filename in stdout.split('\n'):
            filename = filename.strip()
            if not filename:
                continue
            with open(filename, 'r') as fd:
                original_text = fd.read()
            https_ified = switch_to_https_cdn_resources(original_text)
            if https_ified != original_text:
                print('** Converting', filename, 'to HTTPS resources.')
                with open(filename, 'w') as fd:
                    fd.write(https_ified)

    # setupvm
    print('$', 'vagrant-spk setup', ' '.join(args.command_specific_args))
    setup_vm(args)

    # Remove any command-specific args for now.
    args.command_specific_args = []

    # up
    print('$', 'vagrant-spk up')
    bring_up_vm(args)

    # init. This stores a fresh private key.
    print('$', 'vagrant-spk init')
    init(args)

    # Modify the .sandstorm/sandstorm-pkgdef.capnp to contain
    # the git repo name in some way, if there is a git repo here.
    git_repo = None
    git_remote_executor = subprocess.Popen(['git', 'remote', '-v'], stdout=subprocess.PIPE)
    exit_code = git_remote_executor.wait()
    if exit_code == 0:
        stdout = git_remote_executor.communicate()[0]
        git_repo = stdout.split('\n')[0].split()[1]

    if git_repo is not None:
        with open('.sandstorm/sandstorm-pkgdef.capnp') as fd:
            orig_capnp = fd.read()

        # Fix codeUrl =
        assert 'codeUrl = "http://example.com",' in orig_capnp
        improved_capnp = orig_capnp.replace(
            'codeUrl = "http://example.com",',
            'codeUrl = "{0}",'.format(git_repo))

        # Fix appTitle =
        nicertitle = git_repo.split('/')[-1]
        assert '(defaultText = "Example App")' in orig_capnp
        improved_capnp = improved_capnp.replace(
            '(defaultText = "Example App")',
            '(defaultText = "{0}")'.format(nicertitle))

        with open('.sandstorm/sandstorm-pkgdef.capnp', 'w') as fd:
            fd.write(improved_capnp)

    # Run build, but skip spk dev. TODO make less hacky.
    # Skip dev mode, since this is non-interactive for now.
    print('$', 'vagrant-spk dev')
    sandstorm_dir = os.path.join(args.work_directory, ".sandstorm")
    call_vagrant_command(sandstorm_dir, "ssh", "-c", " && ".join([
        "/opt/app/.sandstorm/build.sh",
    ]))

    print("*** Click around and make sure the app works OK ***")

    # TODO: Replace 'Example app' with 'Fantastic app'.

    # Package it.
    args.command_specific_args = ['../app.spk']
    print('$', 'vagrant-spk pack', ' '.join(args.command_specific_args))
    pack(args)
    args.command_specific_args = []

    # Success. Bring down the VM for now, since otherwise port 6080
    # will be in use.
    print('')
    print('You can run:')
    print('$ vagrant-spk halt')
    print('')
    print('When you are ready to stop thinking about packaging this app.')


def setup_vm(args):
    if (len(args.command_specific_args) == 0):
        # No stack specified.  List known stacks.
        print("No stack specified.  Try specifying a stack with:")
        print("")
        print("vagrant-spk setupvm <stack>")
        print("")
        print("Supported stacks:")
        stacks_dir = os.path.join(CODE_DIR, "stacks")
        for stack in sorted(os.listdir(stacks_dir)):
            print("  {}".format(stack))
        print("")
        sys.exit(1)

    stack_plugin_name = args.command_specific_args[0]
    stack_plugin = StackPlugin(stack_plugin_name)
    sandstorm_dir = os.path.join(args.work_directory, ".sandstorm")
    print("Initializing .sandstorm directory in {}".format(sandstorm_dir))
    # Create .sandstorm directory
    if not os.path.isdir(sandstorm_dir):
        os.makedirs(sandstorm_dir, mode=0o755)

    # Make sure ~/.sandstorm exists for storing signing keys
    ensure_host_sandstorm_folder_exists()

    # Copy global setup script to e.g. install and configure sandstorm
    global_setup_script_path = os.path.join(sandstorm_dir, "global-setup.sh")
    with open(global_setup_script_path, "wb") as f:
        f.write(GLOBAL_SETUP_SCRIPT)
    os.chmod(global_setup_script_path, 0o755)

    # Copy stack-specific script to e.g. install and configure nginx, mysql, and php5-fpm
    setup_script_path = os.path.join(sandstorm_dir, "setup.sh")
    with open(setup_script_path, "wb") as f:
        with open(stack_plugin.plugin_file("setup.sh"), "rb") as g:
            f.write(g.read())
    os.chmod(setup_script_path, 0o755)

    # Copy build script, if present, to sandstorm root.  If none is provided by
    # this stack, add an empty one so that users can customize it if needed.
    build_script_path = os.path.join(sandstorm_dir, "build.sh")
    with open(build_script_path, "wb") as f:
        source_script_path = stack_plugin.plugin_file("build.sh")
        if os.path.exists(source_script_path):
            with open(source_script_path, "rb") as g:
                f.write(g.read())
        else:
            f.write(EMPTY_BUILD_SCRIPT)
    os.chmod(build_script_path, 0o755)

    # Copy default launcher script to sandstorm root for spk tracking
    launcher_script_path = os.path.join(sandstorm_dir, "launcher.sh")
    with open(launcher_script_path, "wb") as f:
        with open(stack_plugin.plugin_file("launcher.sh")) as g:
            f.write(g.read())
    os.chmod(launcher_script_path, 0o755)

    # Copy in Vagrantfile
    vagrantfile_path = os.path.join(sandstorm_dir, "Vagrantfile")
    with open(vagrantfile_path, "w") as f:
        f.write(VAGRANTFILE_CONTENTS)

    # Recursively copy in anything in the stack's service-config folder.
    source_service_config_dir = stack_plugin.plugin_file("service-config")
    target_service_config_dir = os.path.join(sandstorm_dir, "service-config")

    # Copy in a .gitignore file. See https://github.com/sandstorm-io/vagrant-spk/issues/30
    gitignore_path = os.path.join(sandstorm_dir, ".gitignore")
    with open(gitignore_path, "ab") as f:
        f.write(GITIGNORE_CONTENTS)

    # Copy in a .gitattributes file. See https://github.com/sandstorm-io/vagrant-spk/issues/55
    gitattributes_path = os.path.join(sandstorm_dir, ".gitattributes")
    with open(gitattributes_path, "ab") as f:
        f.write(GITATTRIBUTES_CONTENTS)

    if os.path.exists(source_service_config_dir):
        if os.path.exists(target_service_config_dir):
            shutil.rmtree(target_service_config_dir)
        shutil.copytree(source_service_config_dir, target_service_config_dir)

    # Make a note of which stack was used
    stack_path = os.path.join(sandstorm_dir, "stack")
    with open(stack_path, "w") as f:
        f.write(stack_plugin_name + "\n")

def bring_up_vm(args):
    sandstorm_dir = os.path.join(args.work_directory, ".sandstorm")
    # Make sure ~/.sandstorm exists, since global-setup.sh uses
    # ~/.sandstorm/caches to cache the installers
    ensure_host_sandstorm_folder_exists()
    # Sanity-check that the user will get a Vagrant box that supports vboxsf, since
    # vagrant-spk depends on that for now.
    ensure_working_vboxsf_in_base_box(sandstorm_dir)
    # Bring up VM
    call_vagrant_command(sandstorm_dir, "up")

def init(args):
    sandstorm_dir = os.path.join(args.work_directory, ".sandstorm")
    # Figure out which stack created this runtime, so we can load appropriate additional init args.
    stack_path = os.path.join(sandstorm_dir, "stack")
    with open(stack_path) as f:
        stack = f.read().strip()
    stack_plugin = StackPlugin(stack)
    init_args = stack_plugin.init_args()
    # Initialize the package with spk init
    call_vagrant_command(sandstorm_dir, "ssh", "-c", "spk init -p 8000 --keyring=/host-dot-sandstorm/sandstorm-keyring --output=/opt/app/.sandstorm/sandstorm-pkgdef.capnp {} -- /bin/bash /opt/app/.sandstorm/launcher.sh".format(init_args))

def dev(args):
    sandstorm_dir = os.path.join(args.work_directory, ".sandstorm")
    call_vagrant_command(sandstorm_dir, "ssh", "-c", " && ".join([
        "/opt/app/.sandstorm/build.sh",
        "cd /opt/app/.sandstorm",
        "spk dev --pkg-def=/opt/app/.sandstorm/sandstorm-pkgdef.capnp:pkgdef"
    ]))

def inject_enter_grain_into_grain(sandstorm_dir, pid, enter_grain_checksum, enter_grain_binary,
                                  tmp_vagrant_spk_dir, enter_grain_binary_path):
    ### The purpose of this function is to take a PID, which is presumably the root process of a
    ### grain within the vagrant-spk VM, and make sure that /tmp/vagrant-spk/enter_grain is the
    ### binary that we want. If is isn't, then inject it.
    sys.stderr.write("Adding enter_grain program to the grain in /tmp/vagrant-spk/enter-grain...\n")
    tmp_vagrant_spk_dir = '/proc/{}/root/tmp/vagrant-spk'.format(pid)
    enter_grain_binary_path = tmp_vagrant_spk_dir + '/enter-grain'
    commands = ' && '.join([
        # Make sure /tmp/vagrant-spk exists in the VM.
        'sudo mkdir -p {}'.format(tmp_vagrant_spk_dir),
        # If the sha1sum tool exists, and the binary in this directory has the right sha1sum,
        # then skip sending it over.
        'if which sha1sum >/dev/null && sudo sha1sum {} 2>/dev/null | grep -q ^{} ; then sudo chmod 755 {} && exit 0 ; fi'.format(
            enter_grain_binary_path, enter_grain_checksum, enter_grain_binary_path),
        # If not, then use dd to inject it in. dd is more convenient than cat here because dd opens
        # the file itself, so `sudo dd` can easily write to files that the "vagrant" user can't.
        'sudo dd of={} 2>/dev/null'.format(enter_grain_binary_path),
        'sudo chmod 755 {}'.format(enter_grain_binary_path),
        ])
    call_vagrant_ssh_command_providing_stdin(
        sandstorm_dir,
        commands,
        stdin=enter_grain_binary)

def shell(args):
    sandstorm_dir = os.path.join(args.work_directory, ".sandstorm")
    try:
        filename = os.path.join(CODE_DIR, 'helpers', 'enter_grain')
        with open(filename, 'rb') as fd:
            enter_grain_binary = fd.read()
        # There should be a .sha1 file next to the binary, just to make sure that it is not
        # accidentally corrupted. If it is the empty string, ignore it; this way, we can avoid
        # checksum errors while developing the binary.
        with open(os.path.join(CODE_DIR, 'helpers', 'enter_grain.sha1'), 'rb') as fd:
            # The first thing in the file, if you split by spaces, is a hex value. There may be
            # other text after it, namely the filename that was checksummed.
            desired_checksum = fd.read().split(' ')[0].strip()
        found_checksum = hashlib.sha1(enter_grain_binary).hexdigest()
        if (desired_checksum and (desired_checksum != found_checksum)):
            raise RuntimeError("ERROR: This vagrant-spk bundle seems to be corrupt: bad checksum on enter_grain binary.")
    except Exception as e:
        sys.stderr.write("ERROR: Failed to load enter_grain binary.")
        raise
    sys.stderr.write("Looking for apps in dev mode...\n")
    # The following vagrant-spk ssh command checks for two things.
    #
    # - Is spk dev running? and
    # - What are the supervisor processes?
    #
    # The supervisor process check also sanity-checks that they are owned by
    # a user ID called sandstorm, which vagrant-spk assumes is the value of
    # SERVER_USER in sandstorm.conf, and looks for the grain ID by looking at
    # argv of the supervisor - the grain ID is the first parameter that does
    # not contain a hyphen. It also searches for the first child process of the
    # supervisor, sorted nondeterministically, but that should be OK because the
    # supervisor should have only one child process.
    #
    # vagrant is slow to start up, so we run both checks in the same vagrant
    # ssh invocation.
    #
    # For safety on Windows especially, and to make it easier to manually test this on Mac/Linux via
    # "vagrant ssh -c '...'", we avoid using any of these characters within the string:
    #
    # - apostrophe: '
    # - quotation mark: "
    # - backslash: \
    data_from_guest = call_vagrant_ssh_command_capturing_output(
        sandstorm_dir,
        r'''pidof spk || echo no-spk;''' +
        r'''SANDSTORM_UID=$(id sandstorm | sed -r s,[^0-9],_,g | sed -r s,_+,_,g | cut -d _ -f 2 ) ; ''' +
        r'''for pid in $(pidof supervisor); do echo $pid $(cat /proc/$pid/status | grep -q 'Uid:.*'${SANDSTORM_UID} && echo ownership-correct || echo ownership-wrong) $(xargs -0 -n1 echo < /proc/$pid/cmdline  | grep -v -- - | head -n2 | tail -n1) $(grep -E -l ^PPid:[[:blank:]]*${pid}$ /proc/*/status | head -n1  | sed -r s,/proc/,,g | sed -r s,/status,,) ; done'''
        # get pid of supervisor, check process owner, get first child process
    )
    splitted = data_from_guest.splitlines()
    spk_pid = splitted[0]
    if spk_pid == 'no-spk':
        sys.stderr.write("No Sandstorm supervisor processes found.\n" +
                         "Try `vagrant-spk dev` first.\n")
        sys.exit(1)
    supervisor_pid_info = splitted[1:]
    sys.stderr.write("Looking for grains...\n")
    if supervisor_pid_info:
        sys.stderr.write('\n')
    else:
        sys.stderr.write("No Sandstorm supervisor processes found.\n" +
                         "Make sure to open a grain of this app in your web browser.\n")
        sys.exit(1)
    supervisors = []
    for line in supervisor_pid_info:
        try:
            supervisor_pid, ownership_check, grain_id, child_pid = line.split()
        except:
            sys.stderr.write('Error parsing line: %s. Crashing.' % line)
            raise
        if ownership_check == 'ownership-correct':
            supervisors.append({
                'supervisor_pid': supervisor_pid,
                'grain_id': grain_id,
                'child_pid': int(child_pid),
            })
    grain_choice_human_readable = raw_input(format_shell_grain_choices(supervisors)).strip()
    if not grain_choice_human_readable:
        grain_choice_human_readable = "1"  # by default
    try:
        grain_choice_as_int = int(grain_choice_human_readable)  # parse into an int
        chosen_supervisor = supervisors[grain_choice_as_int - 1]
    except (ValueError, IndexError):
        sys.stderr.write("Please enter a valid number (e.g. 1).\n")
        sys.exit(1)

    sys.stderr.write("OK. Chosen grain ID %s, whose child PID is %d. Attaching...\n" %
                     (chosen_supervisor['grain_id'], chosen_supervisor['child_pid']))
    pid = chosen_supervisor['child_pid']
    tmp_vagrant_spk_dir = '/proc/{}/root/tmp/vagrant-spk'.format(pid)
    enter_grain_binary_path = tmp_vagrant_spk_dir + '/enter-grain'
    inject_enter_grain_into_grain(
        sandstorm_dir,
        chosen_supervisor['child_pid'],
        desired_checksum,
        enter_grain_binary,
        tmp_vagrant_spk_dir,
        enter_grain_binary_path,
    )
    call_vagrant_command(sandstorm_dir, "ssh", "-c", " && ".join([
        "cd /opt/app/.sandstorm",
        "sudo {} {}".format(enter_grain_binary_path, pid),
    ]))
    sys.stderr.write(
        "NOTE: You should discard all sandstorm-files.list changes from this session to avoid bloat!\n")

def pack(args):
    output_spk = args.command_specific_args[0]
    print(output_spk)
    sandstorm_dir = os.path.join(args.work_directory, ".sandstorm")
    # spk doesn't like to build packages on the vboxsf filesystem due to some
    # oddity when you unlink an open file, so we build the package in the guest
    # homedir, then move it out to the host.
    call_vagrant_command(sandstorm_dir, "ssh", "-c", " && ".join([
        "cd /opt/app/.sandstorm/",
        "spk pack --keyring=/host-dot-sandstorm/sandstorm-keyring --pkg-def=/opt/app/.sandstorm/sandstorm-pkgdef.capnp:pkgdef /home/vagrant/sandstorm-package.spk",
        "spk verify --details /home/vagrant/sandstorm-package.spk",
        "mv /home/vagrant/sandstorm-package.spk /opt/app/sandstorm-package.spk"
    ]))
    os.rename("sandstorm-package.spk", output_spk)
    print("package produced at {}".format(output_spk))

def verify(args):
    spk = args.command_specific_args[0]
    sandstorm_dir = os.path.join(args.work_directory, ".sandstorm")
    spk_basename = os.path.basename(spk)
    temp_spk = os.path.join(sandstorm_dir, spk_basename)

    try:
        shutil.copyfile(spk, temp_spk)
        call_vagrant_command(sandstorm_dir, "ssh", "-c", "spk verify --details /opt/app/.sandstorm/{}".format(spk_basename))
    finally:
        os.remove(temp_spk)

def publish(args):
    if len(args.command_specific_args) == 0:
        print("Please specify an .spk file to publish - e.g.")
        print("  vagrant-spk publish example.spk")
        sys.exit(1)
    # Sadly, we have to copy the spk into the VM since it could be anywhere on the host filesystem
    spk = args.command_specific_args[0]
    sandstorm_dir = os.path.join(args.work_directory, ".sandstorm")
    spk_basename = os.path.basename(spk)
    temp_spk = os.path.join(sandstorm_dir, spk_basename)

    try:
        shutil.copyfile(spk, temp_spk)
        call_vagrant_command(sandstorm_dir, "ssh", "-c", "spk publish --keyring=/host-dot-sandstorm/sandstorm-keyring /opt/app/.sandstorm/{}".format(spk_basename))
    finally:
        os.remove(temp_spk)

def keygen(args):
    sandstorm_dir = os.path.join(args.work_directory, ".sandstorm")
    call_vagrant_command(sandstorm_dir, "ssh", "-c",
            "spk keygen --keyring=/host-dot-sandstorm/sandstorm-keyring {}".format(
                " ".join(args.command_specific_args)
                )
            )

def listkeys(args):
    sandstorm_dir = os.path.join(args.work_directory, ".sandstorm")
    call_vagrant_command(sandstorm_dir, "ssh", "-c",
            "spk listkeys --keyring=/host-dot-sandstorm/sandstorm-keyring {}".format(
                " ".join(args.command_specific_args)
                )
            )

def getkey(args):
    key_id = args.command_specific_args[0]
    sandstorm_dir = os.path.join(args.work_directory, ".sandstorm")
    call_vagrant_command(sandstorm_dir, "ssh", "-c",
            "spk getkey --keyring=/host-dot-sandstorm/sandstorm-keyring {}".format(key_id),
            "--", "-T" # spk getkey refuses to print the output unless isatty() returns false,
                       # so we make sure to disable TTY allocation.
            )

def vm_subcommand(args):
    sandstorm_dir = os.path.join(args.work_directory, ".sandstorm")
    if len(args.command_specific_args) == 0:
        sys.stderr.write("Try specifying a command to pass through to vagrant, like\n\nvagrant-spk vm up\n\n")
        sys.exit(1)

    # Do a couple sanity checks.
    ensure_host_sandstorm_folder_exists()
    if not os.path.exists(sandstorm_dir) or not os.path.exists(os.path.join(sandstorm_dir, "Vagrantfile")):
        sys.stderr.write("You can't call `vm` commands if there's no `.sandstorm` folder.\n" +
                "Try `vagrant-spk setupvm <stack>` first.\n")
        sys.exit(1)

    subcommand = args.command_specific_args[0]
    # Do subcommand specific sanity checks.
    if subcommand == 'up':
        # Sanity-check that the user will get a Vagrant box that supports vboxsf, since
        # vagrant-spk depends on that for now.
        ensure_working_vboxsf_in_base_box(sandstorm_dir)

    call_vagrant_command(sandstorm_dir, *args.command_specific_args)


class Command(object):
    def __init__(self, name, func, helptext, hidden=False):
        self.name = name
        self.func = func # func may be None if this is intended only for the help text
        self.helptext = helptext
        self.hidden = hidden # if true, do not show in vagrant-spk --help


def main():
    global ENABLE_EXPERIMENTAL
    # Switch on feature(s) that we don't think are ready for everyone.
    if os.environ.get("VAGRANT_SPK_EXPERIMENTAL", "").upper() == "Y":
        ENABLE_EXPERIMENTAL = True

    operations = [
        Command('setupvm', setup_vm,
            "Set up a fresh app environment in \n"
            "  --work-directory (using the provided `stack` \n"
            "  command arg).  Also inits developer keys in \n"
            "  ~/.sandstorm on this host."),
        Command('vm', vm_subcommand,
            "Pass through all subsequent arguments to `vagrant` run in `.sandstorm`."),
        Command('vm up', None, "Start the Vagrant VM (and build the VM image if needed)"),
        Command('vm halt', None, "Shut down the Vagrant VM."),
        Command('vm destroy', None, "Delete the Vagrant VM (but leave --work-directory untouched)."),
        Command('vm ssh', None, "SSH into the Vagrant VM."),
        Command('init', init,
            "Initialize fresh Sandstorm package definition \n"
            "  resources in --work-directory."),
        Command('dev', dev,
            "Make the current app available to Sandstorm \n"
            "  in dev mode (after bringing the Vagrant VM `up`)"),
        Command('enter-grain', shell, "Get a shell within a grain"),
        Command('pack', pack,
            "Pack the curent app into a \n"
            "  Sandstorm package."),
        Command('verify', verify,
            "Show details of the specified Sandstorm package."),
        Command('publish', publish,
            "Send the current packed app spk to \n"
            "  the Sandstorm App Market."),
        Command('keygen', keygen,
            "Generate a new key, add it to your keyring,\n"
            "  and print the identifier."),
        Command('listkeys', listkeys,
            "List the keys in your keyring."),
        Command('getkey', getkey,
            "Given a key identifier, retrieve and print the\n"
            "  corresponding private key from your keyring."),
    ]

    if ENABLE_EXPERIMENTAL:
        operations.extend([
            Command('auto', auto,
                    "Automatically package the app in \n"
                    "  --work-directory (using the provided `stack` \n"
                    "  command arg. Also inits developer keys in \n"
                    "  ~/.sandstorm on this host. (EXPERIMENTAL)"),
        ])


    op_to_func = dict((c.name, c.func) for c in operations if c.func)
    ops_helptext = '\n'.join(c.name + ': ' + c.helptext for c in operations if not c.hidden)
    parser = argparse.ArgumentParser(prog=sys.argv[0], formatter_class=argparse.RawTextHelpFormatter)
    parser.add_argument("command", choices=[c.name for c in operations], help=ops_helptext)
    parser.add_argument("command_specific_args", nargs="*")
    parser.add_argument("-V", "--version", action="version", version="vagrant-spk "+__version__)
    parser.add_argument(
        "--work-directory",
        action='store',
        default=PWD,
        help="Use this working directory (e.g. for .sandstorm/ \n"
             "and other configuration).  [Default: current \n"
             "working directory]")
    args = parser.parse_args(sys.argv[1:])
    operation = op_to_func[args.command]
    operation(args)

if __name__ == "__main__":
    main()
